<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoonYetis Slots | Original Graphics v2.1 | Revolutionary Crypto Gaming on Fractal Network</title>
    <meta name="description" content="Play MoonYetis Slots - The ultimate crypto slot machine experience with real MoonYetis BRC-20 tokens on Fractal Bitcoin network.">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style data-version="20250623-032800">
        /* === VARIABLES CSS MOONYETIS UPDATED === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #FF6B35;
            --primary-dark: #E55A2B;
            --secondary: #4ECDC4;
            --accent: #FFE66D;
            --dark: #0A0E1A;
            --darker: #060A14;
            --light: #F8FAFC;
            --gray-100: #F1F5F9;
            --gray-200: #E2E8F0;
            --gray-300: #CBD5E1;
            --gray-400: #94A3B8;
            --gray-500: #64748B;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1E293B;
            --gray-900: #0F172A;
            --gradient-primary: linear-gradient(135deg, #FF6B35 0%, #F7931E 50%, #FFE66D 100%);
            --gradient-dark: linear-gradient(135deg, #0A0E1A 0%, #1E293B 100%);
            --gradient-glass: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            --shadow-xl: 0 35px 60px -12px rgba(0, 0, 0, 0.35);
            --border-radius: 24px;
            --border-radius-sm: 16px;
            --border-radius-lg: 32px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--darker);
            color: var(--light);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
            scroll-behavior: smooth;
        }

        /* === BACKGROUND EFFECTS === */
        .bg-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .bg-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 10%, rgba(255, 107, 53, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 90%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 230, 109, 0.08) 0%, transparent 50%);
            animation: breathe 8s ease-in-out infinite;
        }

        .bg-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--accent);
            border-radius: 50%;
            opacity: 0.6;
            animation: float 15s infinite linear;
        }

        @keyframes breathe {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        /* === HEADER === */
        .header {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 1rem 0;
            background: rgba(10, 14, 26, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 107, 53, 0.1);
            z-index: 1000;
        }

        .header-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            text-decoration: none;
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--light);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-primary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.75rem;
            font-weight: 700;
            color: var(--dark);
            box-shadow: var(--shadow-lg);
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .balance-display {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 12px;
            padding: 0.5rem 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }

        .connect-wallet-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-lg);
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 30px 60px -12px rgba(255, 107, 53, 0.4);
        }

        /* === MAIN SLOT CONTAINER === */
        .slot-container {
            margin-top: 100px;
            padding: 2rem;
            max-width: 1600px;
            margin-left: auto;
            margin-right: auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
            min-height: calc(100vh - 100px);
        }

        .slot-machine-area {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .slot-title {
            text-align: center;
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: 900;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .slot-subtitle {
            text-align: center;
            color: var(--gray-300);
            font-size: 1.1rem;
            margin-bottom: 2rem;
        }

        /* === SLOT MACHINE === */
        .slot-machine {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: var(--border-radius-lg);
            padding: 2rem;
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }

        .slot-machine::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--gradient-primary);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .slot-screen {
            background: var(--dark);
            border: 3px solid var(--gray-700);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }

        .reels-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            height: 240px;
        }

        .reel {
            background: var(--gradient-dark);
            border: 1px solid var(--gray-600);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .reel-strip {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            transition: transform 0.1s ease;
        }

        .reel.spinning .reel-strip {
            animation: spin-reel 0.05s linear infinite;
        }

        @keyframes spin-reel {
            0% { transform: translateY(0); }
            100% { transform: translateY(-80px); }
        }

        .symbol {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Estilos para imágenes de símbolos */
        .symbol-image {
            width: 70px;
            height: 70px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transition: all 0.3s ease;
        }

        .symbol-emoji {
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .symbol.winning .symbol-image {
            filter: drop-shadow(0 0 10px #FFE66D) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transform: scale(1.1);
        }

        /* === ORIGINAL SYMBOL GRAPHICS RESTORED === */
        .symbol-yeti {
            background-image: url('assets/symbols/yeti-wild.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-rocket {
            background-image: url('assets/symbols/rocket-high.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-moon {
            background-image: url('assets/symbols/moon-scatter.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-coin {
            background-image: url('assets/symbols/coin-medium.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-star {
            background-image: url('assets/symbols/star-medium.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-planet {
            background-image: url('assets/symbols/planet-low.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-alien {
            background-image: url('assets/symbols/alien-bonus.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-ufo {
            background-image: url('assets/symbols/ufo-special.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .symbol-diamond {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='diamondGrad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23E0E7FF;stop-opacity:1' /%3E%3Cstop offset='25%25' style='stop-color:%23C7D2FE;stop-opacity:1' /%3E%3Cstop offset='50%25' style='stop-color:%23A5B4FC;stop-opacity:1' /%3E%3Cstop offset='75%25' style='stop-color:%238B5CF6;stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:%237C3AED;stop-opacity:1' /%3E%3C/linearGradient%3E%3Cfilter id='diamondGlow'%3E%3CfeGaussianBlur stdDeviation='4' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cpath d='M50 5 L80 35 L50 95 L20 35 Z' fill='url(%23diamondGrad)' stroke='%23FFFFFF' stroke-width='3' filter='url(%23diamondGlow)'/%3E%3Cpath d='M35 35 L50 20 L65 35 L50 75 Z' fill='%23F0F9FF' opacity='0.6'/%3E%3Cpath d='M40 35 L50 25 L60 35' stroke='%23FFFFFF' stroke-width='2' fill='none' opacity='0.8'/%3E%3C/svg%3E");
        }

        /* === 3D EFFECTS FOR SYMBOLS === */
        .symbol {
            transform-style: preserve-3d;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            background-size: 70px 70px;
        }

        .symbol:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .symbol.winning {
            background-color: rgba(255, 230, 109, 0.15);
            border: 2px solid var(--accent);
            animation: glow 1s ease-in-out infinite alternate, pulse-scale 1.5s ease-in-out infinite;
            transform: scale(1.1);
            box-shadow: 
                0 0 20px var(--accent),
                0 0 40px rgba(255, 230, 109, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        @keyframes pulse-scale {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.15); }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px var(--accent); }
            100% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
        }

        /* === PAYLINES OVERLAY === */
        .paylines-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .payline {
            position: absolute;
            stroke: var(--primary);
            stroke-width: 3;
            fill: none;
            opacity: 0;
            animation: payline-flash 1s ease-in-out;
        }

        .payline.active {
            opacity: 1;
        }

        @keyframes payline-flash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* === CONTROL PANEL === */
        .control-panel {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .control-label {
            font-size: 0.9rem;
            color: var(--gray-300);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent);
        }

        .control-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .control-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* === NEW BETTING CONTROL STYLES === */
        .control-hint {
            color: var(--gray-400);
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
        }

        .total-bet-group {
            background: rgba(255, 107, 53, 0.1);
            border: 2px solid var(--primary);
            border-radius: var(--border-radius-sm);
            padding: 15px;
        }

        .total-bet-value {
            font-size: 1.5rem;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(255, 230, 109, 0.5);
        }

        /* === ULTRA-ACCESSIBLE QUICK BET BUTTONS === */
        .quick-bet-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .quick-bet-btn {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.8) 0%, rgba(247, 147, 30, 0.8) 100%);
            color: var(--light);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 60px;
        }

        .quick-bet-btn:hover {
            background: linear-gradient(135deg, rgba(255, 107, 53, 1) 0%, rgba(247, 147, 30, 1) 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }

        .quick-bet-btn.active {
            background: linear-gradient(135deg, var(--secondary) 0%, #3BB8B1 100%);
            border-color: var(--secondary);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.3);
        }

        .quick-bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* === MICRO-INTERACCIONES ULTRA-ACCESIBLES === */
        
        /* Animación especial para apuestas < 1¢ */
        .micro-bet-glow {
            animation: microBetGlow 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 230, 109, 0.6);
        }

        @keyframes microBetGlow {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(255, 230, 109, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px rgba(255, 230, 109, 0.8);
                transform: scale(1.02);
            }
        }

        /* Efecto "Penny Drop" para micro-wins */
        .penny-drop {
            position: relative;
            overflow: hidden;
        }

        .penny-drop::before {
            content: '¢';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: var(--accent);
            animation: pennyFall 1s ease-in-out;
            opacity: 0;
        }

        .penny-drop.active::before {
            opacity: 1;
        }

        @keyframes pennyFall {
            0% {
                top: -20px;
                opacity: 1;
                transform: translateX(-50%) rotate(0deg);
            }
            100% {
                top: 50px;
                opacity: 0;
                transform: translateX(-50%) rotate(360deg);
            }
        }

        /* Efecto shimmer para botones ultra-accesibles */
        .ultra-accessible-shimmer {
            position: relative;
            overflow: hidden;
        }

        .ultra-accessible-shimmer::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Pulso suave para indicar "casi gratis" */
        .almost-free-pulse {
            animation: almostFreePulse 2s ease-in-out infinite;
        }

        @keyframes almostFreePulse {
            0%, 100% { 
                background: linear-gradient(135deg, rgba(78, 205, 196, 0.8) 0%, rgba(59, 184, 177, 0.8) 100%);
            }
            50% { 
                background: linear-gradient(135deg, rgba(78, 205, 196, 1) 0%, rgba(59, 184, 177, 1) 100%);
            }
        }

        /* Efecto de "micro-win celebration" */
        .micro-win-celebration {
            position: relative;
        }

        .micro-win-celebration::after {
            content: '🎉';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 1.2rem;
            animation: microWinBounce 0.6s ease-in-out;
            opacity: 0;
        }

        .micro-win-celebration.active::after {
            opacity: 1;
        }

        @keyframes microWinBounce {
            0%, 100% { 
                transform: scale(0) rotate(0deg);
                opacity: 0;
            }
            50% { 
                transform: scale(1.2) rotate(10deg);
                opacity: 1;
            }
        }

        /* Hover especial para botones de menos de 1¢ */
        .quick-bet-btn[data-micro="true"]:hover {
            background: linear-gradient(135deg, var(--accent) 0%, #FFD93D 100%);
            color: var(--dark);
            box-shadow: 0 0 15px rgba(255, 230, 109, 0.7);
            transform: translateY(-2px) scale(1.05);
        }

        /* Indicador visual de "ultra-accessible" */
        .ultra-accessible-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--accent);
            color: var(--dark);
            font-size: 0.6rem;
            font-weight: 800;
            padding: 2px 4px;
            border-radius: 8px;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Efecto de loading especial para micro-transacciones */
        .micro-loading {
            position: relative;
        }

        .micro-loading::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid transparent;
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            animation: microSpin 1s linear infinite;
        }

        @keyframes microSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Transition suave para todos los elementos interactivos */
        .quick-bet-btn, .control-btn, .spin-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* === OPTIMIZACIONES MOBILE PARA ULTRA-ACCESSIBLE === */
        
        @media (max-width: 768px) {
            /* Hacer botones más grandes en móvil para mejor accesibilidad */
            .quick-bet-btn {
                font-size: 0.85rem;
                padding: 0.6rem 0.8rem;
                min-height: 44px; /* Mínimo recomendado para touch */
                min-width: 70px;
            }
            
            /* Grid responsive para botones de apuesta */
            .quick-bet-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
            
            /* Badges más visibles en móvil */
            .ultra-accessible-badge {
                font-size: 0.7rem;
                padding: 3px 6px;
                top: -8px;
                right: -8px;
            }
            
            /* Control values más legibles */
            .control-value {
                font-size: 1.1rem;
                font-weight: 600;
            }
            
            /* Tooltips optimizados para móvil */
            .quick-bet-btn[title]:hover::after {
                content: attr(title);
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                background: var(--dark);
                color: var(--light);
                padding: 0.5rem;
                border-radius: 8px;
                font-size: 0.75rem;
                white-space: nowrap;
                z-index: 1000;
                margin-bottom: 5px;
            }
            
            /* Mejores efectos de hover en móvil */
            .quick-bet-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
        }
        
        @media (max-width: 480px) {
            /* Layout especial para pantallas muy pequeñas */
            .quick-bet-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .quick-bet-btn {
                width: 100%;
                justify-content: space-between;
                display: flex;
                align-items: center;
            }
            
            .control-value {
                font-size: 1.2rem;
                line-height: 1.3;
            }
            
            /* Control panel más compacto */
            .control-panel {
                padding: 1rem;
                gap: 1rem;
            }
            
            /* Hacer el título más llamativo en móvil */
            .control-label {
                font-size: 0.85rem;
                margin-bottom: 0.75rem;
            }
        }
        
        /* === OPTIMIZACIONES PARA TOUCH === */
        
        @media (hover: none) and (pointer: coarse) {
            /* Dispositivos touch - eliminar efectos hover confusos */
            .quick-bet-btn:hover {
                transform: none;
                box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
            }
            
            /* Feedback táctil más claro */
            .quick-bet-btn:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }
            
            /* Shimmer más sutil en touch devices */
            .ultra-accessible-shimmer::before {
                animation-duration: 4s;
            }
        }
        
        /* === OPTIMIZACIONES PARA PANTALLAS RETINA === */
        
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* Texto más nítido en pantallas de alta densidad */
            .quick-bet-btn {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
            
            /* Bordes más definidos */
            .ultra-accessible-badge {
                border: 1px solid rgba(0, 0, 0, 0.1);
            }
        }
        
        /* === MODO LANDSCAPE EN MÓVIL === */
        
        @media (max-width: 768px) and (orientation: landscape) {
            .quick-bet-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
            }
            
            .quick-bet-btn {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                min-height: 40px;
            }
        }
        
        /* === ACCESIBILIDAD MEJORADA === */
        
        @media (prefers-reduced-motion: reduce) {
            /* Respetar preferencias de animación reducida */
            .micro-bet-glow,
            .ultra-accessible-shimmer::before,
            .penny-drop::before,
            .almost-free-pulse,
            .micro-win-celebration::after {
                animation: none;
            }
            
            .quick-bet-btn {
                transition: background-color 0.2s ease;
            }
        }
        
        @media (prefers-color-scheme: dark) {
            /* Optimizaciones para modo oscuro */
            .ultra-accessible-badge {
                background: var(--accent);
                color: var(--darker);
                box-shadow: 0 0 10px rgba(255, 230, 109, 0.3);
            }
        }
        
        /* === FOCUS STATES MEJORADOS === */
        
        .quick-bet-btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(255, 230, 109, 0.2);
        }
        
        /* Indicador visual para botones activos */
        .quick-bet-btn.active {
            position: relative;
        }
        
        .quick-bet-btn.active::before {
            content: '✓';
            position: absolute;
            top: -5px;
            left: -5px;
            background: var(--secondary);
            color: var(--dark);
            font-size: 0.7rem;
            font-weight: 800;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spin-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            padding: 1rem 2rem;
            border-radius: var(--border-radius-sm);
            font-size: 1.2rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
            min-width: 140px;
        }

        .spin-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 30px 60px -12px rgba(255, 107, 53, 0.4);
        }

        .spin-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .spin-btn.spinning {
            animation: spin-button 0.5s linear infinite;
        }

        @keyframes spin-button {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .auto-spin-btn {
            background: rgba(78, 205, 196, 0.8);
            color: var(--dark);
        }

        .auto-spin-btn:hover:not(:disabled) {
            box-shadow: 0 30px 60px -12px rgba(78, 205, 196, 0.4);
        }

        .auto-spin-btn.active {
            background: var(--secondary);
            animation: pulse-auto 2s ease-in-out infinite;
        }

        @keyframes pulse-auto {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* === SIDEBAR === */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .info-panel {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 1.5rem;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* === LEADERBOARD === */
        .leaderboard-controls {
            margin-bottom: 1rem;
        }

        .sort-select {
            width: 100%;
            padding: 0.75rem;
            background: var(--darker);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-sm);
            color: var(--light);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }

        .sort-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--border-radius-sm);
            transition: all 0.3s ease;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .leaderboard-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent);
            min-width: 2rem;
            text-align: center;
        }

        .leaderboard-rank.top-3 {
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .leaderboard-player {
            flex: 1;
            margin: 0 0.75rem;
        }

        .leaderboard-wallet {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--light);
            font-family: 'JetBrains Mono', monospace;
        }

        .leaderboard-stats {
            font-size: 0.75rem;
            color: var(--gray-400);
            margin-top: 0.25rem;
        }

        .leaderboard-value {
            text-align: right;
            font-weight: 600;
        }

        .leaderboard-primary {
            font-size: 0.9rem;
            color: var(--primary);
        }

        .leaderboard-secondary {
            font-size: 0.75rem;
            color: var(--gray-400);
            margin-top: 0.25rem;
        }

        .leaderboard-empty {
            text-align: center;
            color: var(--gray-400);
            padding: 2rem;
            font-style: italic;
        }

        .leaderboard-item.current-player {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--primary);
        }

        .leaderboard-item.current-player::before {
            content: "👤";
            position: absolute;
            left: -0.5rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
        }

        /* === PAYTABLE === */
        .paytable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .paytable-item:hover {
            background: rgba(255, 107, 53, 0.1);
            transform: translateX(5px);
        }

        .paytable-symbols {
            display: flex;
            gap: 0.25rem;
            font-size: 1.2rem;
        }

        .paytable-symbol {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: inline-block;
        }

        .paytable-payout {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--accent);
        }

        /* === RECENT WINS === */
        .win-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        .win-amount {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--secondary);
        }

        .win-time {
            font-size: 0.8rem;
            color: var(--gray-400);
        }

        /* === ACHIEVEMENT SYSTEM === */
        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: var(--gradient-primary);
            color: var(--dark);
            padding: 2rem;
            border-radius: var(--border-radius);
            text-align: center;
            z-index: 10000;
            box-shadow: var(--shadow-xl);
            border: 3px solid var(--accent);
            max-width: 400px;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .achievement.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .achievement h3 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .achievement p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        /* === WIN CELEBRATION === */
        .win-celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent);
            animation: fall 3s linear infinite;
        }

        @keyframes fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        /* === JACKPOT DISPLAY === */
        .jackpot-display {
            background: var(--gradient-dark);
            border: 2px solid var(--accent);
            border-radius: var(--border-radius);
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
        }

        .jackpot-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 230, 109, 0.2), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .jackpot-label {
            font-size: 0.9rem;
            color: var(--gray-300);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .jackpot-amount {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 800;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
        }

        /* === MODALS === */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: var(--border-radius);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .modal h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .modal-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
        }

        .modal-btn.secondary {
            background: rgba(78, 205, 196, 0.8);
        }

        /* === RESPONSIVE DESIGN === */
        @media (max-width: 1200px) {
            .slot-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .sidebar {
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .slot-container {
                padding: 1rem;
                margin-top: 80px;
            }
            
            .reels-container {
                height: 180px;
            }
            
            .symbol {
                height: 60px;
                font-size: 1.8rem;
                background-size: 50px 50px;
            }
            
            .control-panel {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            
            .sidebar {
                grid-template-columns: 1fr;
            }
            
            .header-container {
                padding: 0 1rem;
            }
            
            .wallet-info {
                flex-direction: column;
                gap: 0.5rem;
            }
        }

        @media (max-width: 480px) {
            .slot-title {
                font-size: 1.8rem;
            }
            
            .slot-machine {
                padding: 1rem;
            }
            
            .reels-container {
                gap: 0.25rem;
                height: 150px;
            }
            
            .symbol {
                height: 50px;
                font-size: 1.4rem;
                background-size: 40px 40px;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
        }

        /* === LOADING STATES === */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* === STATUS INDICATORS === */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .status-indicator.connected {
            background: rgba(78, 205, 196, 0.2);
            color: var(--secondary);
            border: 1px solid var(--secondary);
        }

        .status-indicator.disconnected {
            background: rgba(255, 107, 53, 0.2);
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        .status-indicator.processing {
            background: rgba(255, 230, 109, 0.2);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* === FREE SPINS STYLING === */
        .free-spins-mode {
            border: 3px solid var(--secondary) !important;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.5) !important;
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(78, 205, 196, 0.05)) !important;
        }

        .free-spins-mode::before {
            background: linear-gradient(90deg, var(--secondary), var(--accent), var(--secondary)) !important;
            animation: freeSpinsPulse 1s ease-in-out infinite !important;
        }

        @keyframes freeSpinsPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .free-spins-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--secondary);
            color: var(--dark);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 800;
            z-index: 100;
            animation: bounce 2s infinite;
        }

        /* === TURBO MODE STYLING === */
        .turbo-mode .slot-machine {
            border: 3px solid var(--accent) !important;
            box-shadow: 0 0 30px rgba(255, 230, 109, 0.5) !important;
            background: linear-gradient(135deg, rgba(255, 230, 109, 0.1), rgba(255, 230, 109, 0.05)) !important;
        }

        .turbo-mode .slot-machine::before {
            background: linear-gradient(90deg, var(--accent), var(--primary), var(--accent)) !important;
            animation: turboPulse 0.5s ease-in-out infinite !important;
        }

        @keyframes turboPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .turbo-mode .reel.spinning .reel-strip {
            animation: spin-reel 0.02s linear infinite !important; /* 3x faster */
        }

        .turbo-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--accent);
            color: var(--dark);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 800;
            font-size: 0.9rem;
            z-index: 100;
            animation: turboFlash 1s infinite;
        }

        @keyframes turboFlash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* === AUDIO CONTROLS STYLING === */
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0.5rem;
        }

        .audio-toggle-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .audio-toggle-btn:hover {
            transform: scale(1.1);
        }

        .audio-toggle-btn.muted {
            background: var(--gray-600);
            opacity: 0.6;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            border-radius: 2px;
            background: var(--gray-600);
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
        }

        /* === SETTINGS PANEL === */
        .settings-panel {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 1.5rem;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-weight: 600;
            color: var(--light);
        }

        .setting-description {
            font-size: 0.85rem;
            color: var(--gray-400);
            margin-top: 0.25rem;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 25px;
            background: var(--gray-600);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(25px);
        }

        /* === ADVANCED WALLET PANEL STYLES === */
        
        /* Wallet Panel Toggle Button */
        .wallet-panel-toggle {
            background: linear-gradient(135deg, #4ECDC4 0%, #44C7C1 100%);
            color: var(--dark);
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius-sm);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .wallet-panel-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.3);
        }

        /* Wallet Panel Overlay */
        .wallet-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .wallet-panel.active {
            display: flex;
            opacity: 1;
        }

        .wallet-panel-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        /* Wallet Panel Content */
        .wallet-panel-content {
            position: relative;
            margin: auto;
            background: var(--gradient-dark);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: var(--border-radius-lg);
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            animation: walletPanelSlideIn 0.4s ease;
        }

        @keyframes walletPanelSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Wallet Panel Header */
        .wallet-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--gradient-glass);
        }

        .wallet-panel-header h2 {
            margin: 0;
            color: var(--light);
            font-size: 1.5rem;
        }

        .wallet-panel-close {
            background: rgba(255, 107, 53, 0.2);
            color: var(--light);
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .wallet-panel-close:hover {
            background: var(--primary);
            transform: scale(1.1);
        }

        /* Wallet Tabs */
        .wallet-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .wallet-tab {
            flex: 1;
            background: transparent;
            color: var(--gray-300);
            border: none;
            padding: 15px 10px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .wallet-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
        }

        .wallet-tab.active {
            background: rgba(255, 107, 53, 0.1);
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Wallet Tab Content */
        .wallet-tab-content {
            display: none;
            padding: 25px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .wallet-tab-content.active {
            display: block;
        }

        /* Balance Overview */
        .balance-overview {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .balance-card {
            background: var(--gradient-glass);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
        }

        .main-balance {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1) 0%, rgba(255, 230, 109, 0.1) 100%);
            border-color: rgba(255, 107, 53, 0.3);
        }

        .balance-label {
            color: var(--gray-300);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .balance-amount {
            color: var(--light);
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }


        .balance-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .balance-cards-grid .balance-amount {
            font-size: 1.3rem;
        }

        /* Wallet Actions */
        .wallet-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .wallet-action-btn {
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            padding: 12px 24px;
            border-radius: var(--border-radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
        }

        .wallet-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.3);
        }

        .deposit-btn {
            background: linear-gradient(135deg, #4ECDC4 0%, #44C7C1 100%);
        }

        .withdraw-btn {
            background: linear-gradient(135deg, #FF6B35 0%, #E55A2B 100%);
        }

        .refresh-btn {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: var(--light);
        }

        /* Transaction Filters */
        .transaction-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .filter-select {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius-sm);
            padding: 8px 12px;
            font-size: 0.9rem;
        }

        .filter-btn {
            background: var(--secondary);
            color: var(--dark);
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background: #44C7C1;
            transform: translateY(-1px);
        }

        /* Transaction Table */
        .transaction-table-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--border-radius);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .transaction-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transaction-table th {
            background: rgba(255, 107, 53, 0.1);
            color: var(--light);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .transaction-table td {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--gray-200);
            font-size: 0.9rem;
        }

        .transaction-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .no-transactions td {
            text-align: center;
            padding: 40px;
            color: var(--gray-400);
            font-style: italic;
        }

        /* Deposit Section */
        .deposit-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .deposit-address-card {
            background: var(--gradient-glass);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 20px;
        }

        .deposit-address-card h3 {
            margin-bottom: 15px;
            color: var(--light);
        }

        .address-display {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .address-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius-sm);
            padding: 10px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .copy-btn {
            background: var(--secondary);
            color: var(--dark);
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: #44C7C1;
            transform: scale(1.05);
        }

        .qr-code-container {
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: var(--border-radius-sm);
        }

        /* Deposit Info */
        .deposit-info {
            background: rgba(255, 230, 109, 0.1);
            border: 1px solid rgba(255, 230, 109, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .info-label {
            color: var(--gray-300);
        }

        .info-value {
            color: var(--light);
            font-weight: 600;
        }

        /* Withdraw Section */
        .withdraw-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .withdraw-form {
            background: var(--gradient-glass);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            padding: 25px;
        }

        .withdraw-form h3 {
            margin-bottom: 20px;
            color: var(--light);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: var(--gray-300);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius-sm);
            padding: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
        }

        .amount-helpers {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .amount-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius-sm);
            padding: 6px 12px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .amount-btn:hover {
            background: var(--primary);
            color: var(--dark);
            border-color: var(--primary);
        }

        .withdraw-info {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: var(--border-radius-sm);
            padding: 15px;
            margin: 20px 0;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: var(--gray-200);
        }

        .info-row.total {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
            font-weight: 600;
            color: var(--light);
            font-size: 1.1rem;
        }

        .withdraw-submit-btn {
            width: 100%;
            background: var(--gradient-primary);
            color: var(--dark);
            border: none;
            padding: 15px;
            border-radius: var(--border-radius);
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .withdraw-submit-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
        }

        .withdraw-submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .wallet-panel-content {
                width: 95%;
                max-height: 95vh;
            }

            .wallet-tabs {
                flex-wrap: wrap;
            }

            .wallet-tab {
                min-width: 50%;
                font-size: 0.8rem;
                padding: 12px 8px;
            }

            .balance-cards-grid {
                grid-template-columns: 1fr;
            }

            .wallet-actions {
                flex-direction: column;
                align-items: center;
            }

            .transaction-filters {
                flex-direction: column;
                gap: 10px;
            }

            .filter-select, .filter-btn {
                width: 100%;
            }

            .address-display {
                flex-direction: column;
            }

            .amount-helpers {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
        }

        /* === REAL-TIME NOTIFICATIONS SYSTEM === */
        
        /* Notification Toast Container */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
            max-width: 400px;
        }

        /* Individual Notification Toast */
        .notification-toast {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            padding: 16px 20px;
            box-shadow: var(--shadow-xl);
            animation: slideInFromRight 0.4s ease-out;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            min-height: 80px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .notification-toast.success {
            border-left: 4px solid #4ECDC4;
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.15) 0%, rgba(68, 199, 193, 0.1) 100%);
        }

        .notification-toast.progress {
            border-left: 4px solid #FFE66D;
            background: linear-gradient(135deg, rgba(255, 230, 109, 0.15) 0%, rgba(255, 195, 0, 0.1) 100%);
        }

        .notification-toast.error {
            border-left: 4px solid #FF6B35;
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.15) 0%, rgba(229, 90, 43, 0.1) 100%);
        }

        .notification-toast.info {
            border-left: 4px solid #6c757d;
            background: linear-gradient(135deg, rgba(108, 117, 125, 0.15) 0%, rgba(73, 80, 87, 0.1) 100%);
        }

        /* Notification Icon */
        .notification-icon {
            font-size: 2rem;
            flex-shrink: 0;
            line-height: 1;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .notification-toast.success .notification-icon::before { content: '✅'; }
        .notification-toast.progress .notification-icon::before { content: '⏳'; }
        .notification-toast.error .notification-icon::before { content: '❌'; }
        .notification-toast.info .notification-icon::before { content: 'ℹ️'; }

        /* Notification Content */
        .notification-content {
            flex: 1;
            min-width: 0;
        }

        .notification-title {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 5px;
            color: var(--light);
            line-height: 1.3;
        }

        .notification-message {
            font-size: 0.85rem;
            color: var(--gray-300);
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .notification-details {
            font-size: 0.75rem;
            color: var(--gray-400);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Progress Bar for Confirmation Notifications */
        .notification-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .notification-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ECDC4, #FFE66D);
            transition: width 0.6s ease;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        /* Close Button */
        .notification-close {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: var(--gray-400);
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .notification-close:hover {
            opacity: 1;
            color: var(--light);
        }

        /* Auto-dismiss Timer */
        .notification-timer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .notification-timer-bar {
            height: 100%;
            background: var(--primary);
            animation: notificationTimer 5s linear;
        }

        /* Animations */
        @keyframes slideInFromRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        @keyframes notificationTimer {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* Live Status Indicators */
        .live-status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            animation: pulse 2s infinite;
        }

        .live-status-indicator.connected {
            background: rgba(78, 205, 196, 0.2);
            color: #4ECDC4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .live-status-indicator.disconnected {
            background: rgba(255, 107, 53, 0.2);
            color: #FF6B35;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .live-status-indicator::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            animation: blink 1.5s infinite;
        }

        /* Progress Ring for Confirmations */
        .confirmation-progress-ring {
            width: 40px;
            height: 40px;
            position: relative;
            margin-right: 10px;
        }

        .confirmation-progress-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .confirmation-progress-ring circle {
            fill: none;
            stroke-width: 3;
        }

        .confirmation-progress-ring .background {
            stroke: rgba(255, 255, 255, 0.1);
        }

        .confirmation-progress-ring .progress {
            stroke: #4ECDC4;
            stroke-linecap: round;
            transition: stroke-dasharray 0.6s ease;
        }

        .confirmation-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--light);
        }

        /* Enhanced Pending Deposits Section */
        .pending-deposit-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-sm);
            padding: 16px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }

        .pending-deposit-item.updating {
            animation: pulse 1.5s infinite;
            border-color: rgba(78, 205, 196, 0.4);
        }

        .pending-deposit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .pending-deposit-amount {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--light);
        }

        .pending-deposit-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 8px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .pending-deposit-status.first_confirmation {
            background: rgba(255, 230, 109, 0.2);
            color: #FFE66D;
        }

        .pending-deposit-status.half_confirmed {
            background: rgba(255, 195, 0, 0.2);
            color: #FFC300;
        }

        .pending-deposit-status.nearly_confirmed {
            background: rgba(78, 205, 196, 0.2);
            color: #4ECDC4;
        }

        .pending-deposit-details {
            font-size: 0.85rem;
            color: var(--gray-300);
            margin-bottom: 8px;
        }

        .pending-deposit-eta {
            font-size: 0.75rem;
            color: var(--gray-400);
            font-style: italic;
        }

        /* Real-time Balance Updates */
        .balance-updating {
            position: relative;
            overflow: hidden;
        }

        .balance-updating::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .notification-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .notification-toast {
                padding: 14px 16px;
                min-height: 70px;
            }

            .notification-icon {
                font-size: 1.5rem;
            }

            .notification-title {
                font-size: 0.9rem;
            }

            .notification-message {
                font-size: 0.8rem;
            }
        }

        /* === SETTINGS AND AUDIT MODAL STYLES === */
        
        /* Settings Button */
        .wallet-panel-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .wallet-settings-btn {
            background: var(--gradient-glass);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: var(--light);
            padding: 8px 12px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .wallet-settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        .settings-modal-content {
            background: var(--gradient-dark);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            animation: slideInFromBottom 0.3s ease-out;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-header h3 {
            margin: 0;
            color: var(--light);
            font-size: 1.4rem;
        }

        .settings-close {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .settings-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .settings-body {
            padding: 24px;
        }

        .setting-group {
            margin-bottom: 32px;
        }

        .setting-group h4 {
            color: var(--accent);
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(255, 230, 109, 0.2);
            padding-bottom: 8px;
        }

        .setting-item {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            color: var(--light);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .setting-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-item select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: var(--light);
            padding: 10px 12px;
            font-size: 14px;
        }

        .setting-item select option {
            background: var(--dark);
            color: var(--light);
        }

        .test-sounds-btn, .debug-btn {
            background: var(--gradient-primary);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .test-sounds-btn:hover, .debug-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.3);
        }

        .settings-footer {
            padding: 20px 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .settings-save-btn {
            background: var(--gradient-primary);
            border: none;
            border-radius: 12px;
            color: white;
            padding: 14px 28px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .settings-save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.4);
        }

        /* Audit Modal */
        .audit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 21000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        .audit-modal-content {
            background: var(--gradient-dark);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
        }

        .audit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .audit-header h3 {
            margin: 0;
            color: var(--light);
            font-size: 1.4rem;
        }

        .audit-close {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .audit-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .audit-body {
            padding: 24px;
            max-height: 500px;
            overflow-y: auto;
        }

        .audit-log-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .log-time {
            color: var(--accent);
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .log-type {
            color: var(--secondary);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .log-data {
            color: var(--gray-300);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInFromBottom {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .settings-modal-content, .audit-modal-content {
                width: 95%;
                max-height: 90vh;
                margin: 20px;
            }
            
            .settings-body, .audit-body {
                padding: 16px;
            }
            
            .settings-header, .audit-header {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Background Effects -->
    <div class="bg-effects">
        <div class="bg-gradient"></div>
        <div class="bg-particles" id="particles"></div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="#" class="logo">
                <div class="logo-icon">MY</div>
                MoonYetis Slots
            </a>
            
            <div class="wallet-info">
                <div class="audio-controls">
                    <button class="audio-toggle-btn" id="audioToggle" title="Toggle Audio">
                        🔊
                    </button>
                    <input type="range" class="volume-slider" id="volumeSlider" 
                           min="0" max="100" value="70" title="Master Volume">
                </div>
                
                <div class="status-indicator disconnected" id="connectionStatus">
                    <span>🔗</span>
                    <span id="statusText">Not Connected</span>
                </div>
                
                <div class="balance-display" id="balanceDisplay">
                    Balance: <span id="balance">0</span> MY
                </div>
                
                <button class="connect-wallet-btn" id="connectWallet">
                    <span id="walletBtnText">Connect Wallet</span>
                </button>
                
                <button class="wallet-panel-toggle" id="walletPanelToggle" title="Open Advanced Wallet">
                    💰 Wallet
                </button>
            </div>
        </div>
    </header>

    <!-- Advanced Wallet Panel -->
    <div class="wallet-panel" id="walletPanel">
        <div class="wallet-panel-backdrop" id="walletPanelBackdrop"></div>
        <div class="wallet-panel-content">
            <div class="wallet-panel-header">
                <h2>💰 MoonYetis Wallet</h2>
                <div class="wallet-panel-controls">
                    <button class="wallet-settings-btn" id="walletSettingsBtn" title="Configuraciones">⚙️</button>
                    <button class="wallet-panel-close" id="walletPanelClose">✕</button>
                </div>
            </div>
            
            <div class="wallet-tabs">
                <button class="wallet-tab active" data-tab="balance">💳 Balance</button>
                <button class="wallet-tab" data-tab="history">📜 Historial</button>
                <button class="wallet-tab" data-tab="deposit">⬇️ Depósito</button>
                <button class="wallet-tab" data-tab="withdraw">⬆️ Retiro</button>
            </div>
            
            <!-- Balance Tab -->
            <div class="wallet-tab-content active" id="balance-tab">
                <div class="balance-overview">
                    <div class="balance-card main-balance">
                        <div class="balance-label">Balance Total</div>
                        <div class="balance-amount" id="walletMainBalance">0 MY</div>
                    </div>
                    
                    <div class="balance-cards-grid">
                        <div class="balance-card">
                            <div class="balance-label">Total Depositado</div>
                            <div class="balance-amount" id="totalDeposited">0 MY</div>
                        </div>
                        <div class="balance-card">
                            <div class="balance-label">Total Ganado</div>
                            <div class="balance-amount" id="totalWon">0 MY</div>
                        </div>
                        <div class="balance-card">
                            <div class="balance-label">Total Apostado</div>
                            <div class="balance-amount" id="totalWagered">0 MY</div>
                        </div>
                    </div>
                    
                    <div class="wallet-actions">
                        <button class="wallet-action-btn deposit-btn" data-action="deposit">
                            ⬇️ Depositar
                        </button>
                        <button class="wallet-action-btn withdraw-btn" data-action="withdraw">
                            ⬆️ Retirar
                        </button>
                        <button class="wallet-action-btn refresh-btn" id="refreshBalance">
                            🔄 Actualizar
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- History Tab -->
            <div class="wallet-tab-content" id="history-tab">
                <div class="transaction-filters">
                    <select id="transactionType" class="filter-select">
                        <option value="all">Todos los tipos</option>
                        <option value="deposit">Depósitos</option>
                        <option value="withdraw">Retiros</option>
                        <option value="bet">Apuestas</option>
                        <option value="win">Ganancias</option>
                    </select>
                    
                    <select id="transactionStatus" class="filter-select">
                        <option value="all">Todos los estados</option>
                        <option value="pending">Pendiente</option>
                        <option value="confirmed">Confirmado</option>
                        <option value="failed">Fallido</option>
                    </select>
                    
                    <button class="filter-btn" id="exportTransactions">📄 Exportar</button>
                </div>
                
                <div class="transaction-table-container">
                    <table class="transaction-table">
                        <thead>
                            <tr>
                                <th>Fecha</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Estado</th>
                                <th>Hash</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="transactionTableBody">
                            <tr class="no-transactions">
                                <td colspan="6">No hay transacciones disponibles</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="pagination" id="transactionPagination">
                    <!-- Pagination will be generated dynamically -->
                </div>
            </div>
            
            <!-- Deposit Tab -->
            <div class="wallet-tab-content" id="deposit-tab">
                <div class="deposit-section">
                    <div class="deposit-address-card">
                        <h3>Dirección de Depósito</h3>
                        <div class="address-display">
                            <input type="text" class="address-input" id="depositAddress" readonly>
                            <button class="copy-btn" id="copyDepositAddress">📋</button>
                        </div>
                        <div class="qr-code-container" id="depositQR">
                            <!-- QR Code will be generated here -->
                        </div>
                    </div>
                    
                    <div class="deposit-info">
                        <div class="info-item">
                            <span class="info-label">Red:</span>
                            <span class="info-value">Fractal Bitcoin</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Token:</span>
                            <span class="info-value">MOONYETIS (MY)</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Mínimo:</span>
                            <span class="info-value">1,000 MY</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Confirmaciones:</span>
                            <span class="info-value">1</span>
                        </div>
                    </div>
                    
                    <div class="pending-deposits" id="pendingDeposits">
                        <h4>Depósitos Pendientes</h4>
                        <div class="pending-list" id="pendingDepositsList">
                            <!-- Pending deposits will be shown here -->
                        </div>
                    </div>
                    
                    <!-- Real-time Notifications Section -->
                    <div class="notification-status" id="notificationStatus">
                        <div class="connection-indicator" id="wsConnectionStatus">
                            <span class="status-dot offline"></span>
                            <span class="status-text">Desconectado</span>
                        </div>
                        <button class="connect-notifications-btn" id="connectNotifications">
                            📢 Activar Notificaciones
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Withdraw Tab -->
            <div class="wallet-tab-content" id="withdraw-tab">
                <div class="withdraw-section">
                    <div class="withdraw-form">
                        <h3>Retirar MOONYETIS</h3>
                        
                        <div class="form-group">
                            <label for="withdrawAddress">Dirección de Destino</label>
                            <input type="text" id="withdrawAddress" class="form-input" 
                                   placeholder="Ingresa la dirección de tu wallet">
                        </div>
                        
                        <div class="form-group">
                            <label for="withdrawAmount">Cantidad (MY)</label>
                            <input type="number" id="withdrawAmount" class="form-input" 
                                   placeholder="0" min="1000">
                            <div class="amount-helpers">
                                <button class="amount-btn" data-amount="25">25%</button>
                                <button class="amount-btn" data-amount="50">50%</button>
                                <button class="amount-btn" data-amount="75">75%</button>
                                <button class="amount-btn" data-amount="100">MAX</button>
                            </div>
                        </div>
                        
                        <div class="withdraw-info">
                            <div class="info-row">
                                <span>Cantidad a retirar:</span>
                                <span id="withdrawAmountDisplay">0 MY</span>
                            </div>
                            <div class="info-row">
                                <span>Comisión de red:</span>
                                <span id="withdrawFee">1,000 MY</span>
                            </div>
                            <div class="info-row total">
                                <span>Total a recibir:</span>
                                <span id="withdrawTotal">0 MY</span>
                            </div>
                        </div>
                        
                        <button class="withdraw-submit-btn" id="submitWithdraw" disabled>
                            ⬆️ Retirar MOONYETIS
                        </button>
                    </div>
                    
                    <div class="withdraw-status" id="withdrawStatus" style="display: none;">
                        <!-- Withdrawal status will be shown here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Real-time Notifications Container -->
    <div class="notification-container" id="notificationContainer">
        <!-- Toast notifications will appear here -->
    </div>

    <!-- Main Container -->
    <div class="slot-container">
        <!-- Slot Machine Area -->
        <div class="slot-machine-area">
            <h1 class="slot-title">🎰 MoonYetis Slots</h1>
            <p class="slot-subtitle">
                Play with real MoonYetis BRC-20 tokens on Fractal Bitcoin Network
                <br><small style="color: var(--secondary);">✨ Experience the future of crypto gambling</small>
            </p>

            <!-- Jackpot Display -->
            <div class="jackpot-display">
                <div class="jackpot-label">🏆 Progressive Jackpot</div>
                <div class="jackpot-amount" id="jackpotAmount">125,847 MY</div>
            </div>

            <!-- Slot Machine -->
            <div class="slot-machine">
                <div class="slot-screen">
                    <div class="reels-container" id="reelsContainer">
                        <!-- Reels will be generated dynamically -->
                    </div>
                    
                    <!-- Paylines Overlay -->
                    <div class="paylines-overlay">
                        <svg width="100%" height="100%" id="paylinesOverlay">
                            <!-- Paylines will be drawn here -->
                        </svg>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="control-panel">
                    <div class="control-group">
                        <div class="control-label">Apuesta por Línea</div>
                        <div class="control-value" id="betAmount">10,000 MY</div>
                        <div class="control-buttons">
                            <button class="control-btn" id="betDown">-5K</button>
                            <button class="control-btn" id="betUp">+5K</button>
                        </div>
                        <div class="control-hint">Rango: 10K - 100K MY</div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">Líneas Activas</div>
                        <div class="control-value" id="activeLines">25</div>
                        <div class="control-buttons">
                            <button class="control-btn" id="linesDown">-5</button>
                            <button class="control-btn" id="linesUp">+5</button>
                        </div>
                        <div class="control-hint">Rango: 1-25 líneas</div>
                    </div>

                    <div class="control-group total-bet-group">
                        <div class="control-label">Apuesta Total</div>
                        <div class="control-value total-bet-value" id="totalBet">250,000 MY</div>
                        <div class="control-hint">
                            <span id="betCalculation">10,000 MY × 25 líneas = 250,000 MY total (máx: 2,500,000 MY)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <button class="spin-btn" id="spinBtn">
                            <span id="spinBtnText">🎯 SPIN</span>
                        </button>
                    </div>


                    <div class="control-group">
                        <div class="control-label">Last Win</div>
                        <div class="control-value" id="lastWin">0 MY</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Paytable -->
            <div class="info-panel">
                <h3 class="panel-title">💰 Paytable</h3>
                <div id="paytable">
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-yeti"></div>
                            <div class="paytable-symbol symbol-yeti"></div>
                            <div class="paytable-symbol symbol-yeti"></div>
                            <div class="paytable-symbol symbol-yeti"></div>
                            <div class="paytable-symbol symbol-yeti"></div>
                        </div>
                        <div class="paytable-payout">100x</div>
                    </div>
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-rocket"></div>
                            <div class="paytable-symbol symbol-rocket"></div>
                            <div class="paytable-symbol symbol-rocket"></div>
                            <div class="paytable-symbol symbol-rocket"></div>
                            <div class="paytable-symbol symbol-rocket"></div>
                        </div>
                        <div class="paytable-payout">50x</div>
                    </div>
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-moon"></div>
                            <div class="paytable-symbol symbol-moon"></div>
                            <div class="paytable-symbol symbol-moon"></div>
                            <div class="paytable-symbol symbol-moon"></div>
                            <div class="paytable-symbol symbol-moon"></div>
                        </div>
                        <div class="paytable-payout">30x</div>
                    </div>
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-coin"></div>
                            <div class="paytable-symbol symbol-coin"></div>
                            <div class="paytable-symbol symbol-coin"></div>
                            <div class="paytable-symbol symbol-coin"></div>
                            <div class="paytable-symbol symbol-coin"></div>
                        </div>
                        <div class="paytable-payout">20x</div>
                    </div>
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-star"></div>
                            <div class="paytable-symbol symbol-star"></div>
                            <div class="paytable-symbol symbol-star"></div>
                            <div class="paytable-symbol symbol-star"></div>
                            <div class="paytable-symbol symbol-star"></div>
                        </div>
                        <div class="paytable-payout">15x</div>
                    </div>
                    <div class="paytable-item">
                        <div class="paytable-symbols">
                            <div class="paytable-symbol symbol-planet"></div>
                            <div class="paytable-symbol symbol-planet"></div>
                            <div class="paytable-symbol symbol-planet"></div>
                            <div class="paytable-symbol symbol-planet"></div>
                            <div class="paytable-symbol symbol-planet"></div>
                        </div>
                        <div class="paytable-payout">10x</div>
                    </div>
                    <div style="text-align: center; padding: 1rem; margin-top: 1rem; background: rgba(255, 107, 53, 0.1); border-radius: 8px; border: 1px solid rgba(255, 107, 53, 0.3);">
                        <div style="font-size: 0.9rem; color: var(--gray-300); margin-bottom: 0.5rem;">Game Info</div>
                        <div style="font-size: 0.8rem; color: var(--gray-400);">
                            RTP: 96% | Volatility: Medium<br>
                            <div class="paytable-symbol symbol-yeti" style="display: inline-block; width: 16px; height: 16px; vertical-align: middle;"></div> = Wild | <div class="paytable-symbol symbol-moon" style="display: inline-block; width: 16px; height: 16px; vertical-align: middle;"></div> = Scatter
                        </div>
                    </div>
                </div>
            </div>

            <!-- Game Stats -->
            <div class="info-panel">
                <h3 class="panel-title">📊 Game Stats</h3>
                <div style="display: grid; gap: 0.75rem;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>Spins Played:</span>
                        <span id="totalSpins" style="color: var(--accent); font-weight: 700;">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Total Wagered:</span>
                        <span id="totalWagered" style="color: var(--accent); font-weight: 700;">0 MY</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Total Won:</span>
                        <span id="totalWon" style="color: var(--secondary); font-weight: 700;">0 MY</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Biggest Win:</span>
                        <span id="biggestWin" style="color: var(--primary); font-weight: 700;">0 MY</span>
                    </div>
                </div>
            </div>

            <!-- Recent Wins -->
            <div class="info-panel">
                <h3 class="panel-title">🎉 Recent Wins</h3>
                <div id="recentWins">
                    <div style="text-align: center; color: var(--gray-400); padding: 2rem;">
                        <p>🎯 Start playing to see your wins!</p>
                    </div>
                </div>
            </div>

            <!-- Global Leaderboard -->
            <div class="info-panel">
                <h3 class="panel-title">🏆 Global Leaderboard</h3>
                <div id="leaderboard">
                    <div class="leaderboard-controls">
                        <select id="leaderboardSort" class="sort-select">
                            <option value="total_wagered">Total Wagered</option>
                            <option value="biggest_win">Biggest Win</option>
                            <option value="profit_loss">Profit/Loss</option>
                            <option value="total_spins">Total Spins</option>
                        </select>
                    </div>
                    <div id="leaderboardList">
                        <div style="text-align: center; color: var(--gray-400); padding: 2rem;">
                            <p>🏆 Loading global rankings...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Game Settings -->
            <div class="info-panel">
                <h3 class="panel-title">⚙️ Game Settings</h3>
                <div class="settings-panel">
                    <div class="setting-item">
                        <div>
                            <div class="setting-label">Turbo Mode</div>
                            <div class="setting-description">3x faster spins and animations</div>
                        </div>
                        <div class="toggle-switch" id="turboToggle"></div>
                    </div>
                    
                    <div class="setting-item">
                        <div>
                            <div class="setting-label">Sound Effects</div>
                            <div class="setting-description">Game sounds and audio feedback</div>
                        </div>
                        <div class="toggle-switch active" id="audioToggleSwitch"></div>
                    </div>
                    
                    <div class="setting-item">
                        <div>
                            <div class="setting-label">Background Music</div>
                            <div class="setting-description">Ambient space music</div>
                        </div>
                        <div class="toggle-switch" id="musicToggle"></div>
                    </div>
                    
                    <div class="setting-item">
                        <div>
                            <div class="setting-label">Master Volume</div>
                            <div class="setting-description">Overall audio volume</div>
                        </div>
                        <input type="range" class="volume-slider" id="masterVolumeSlider" 
                               min="0" max="100" value="70" style="width: 100px;">
                    </div>
                </div>
            </div>

            <!-- Achievements -->
            <div class="info-panel">
                <h3 class="panel-title">🏆 Achievements</h3>
                <div id="achievements">
                    <div style="display: grid; gap: 0.5rem;">
                        <div class="achievement-item" data-achievement="first-spin">
                            <span style="opacity: 0.5;">🎰 First Spin</span>
                        </div>
                        <div class="achievement-item" data-achievement="lucky-seven">
                            <span style="opacity: 0.5;">🍀 Lucky Seven (7 wins)</span>
                        </div>
                        <div class="achievement-item" data-achievement="high-roller">
                            <span style="opacity: 0.5;">💎 High Roller (50 MY bet)</span>
                        </div>
                        <div class="achievement-item" data-achievement="big-winner">
                            <span style="opacity: 0.5;">🎯 Big Winner (20x multiplier)</span>
                        </div>
                        <div class="achievement-item" data-achievement="free-spins-winner">
                            <span style="opacity: 0.5;">🌙 Free Spins Master</span>
                        </div>
                        <div class="achievement-item" data-achievement="first-bonus">
                            <span style="opacity: 0.5;">🎮 First Bonus Round</span>
                        </div>
                        <div class="achievement-item" data-achievement="bonus-master">
                            <span style="opacity: 0.5;">🏆 Bonus Master (5 rounds)</span>
                        </div>
                        <div class="achievement-item" data-achievement="space-explorer">
                            <span style="opacity: 0.5;">🚀 Space Explorer (50 spins)</span>
                        </div>
                        <div class="achievement-item" data-achievement="persistent-player">
                            <span style="opacity: 0.5;">⭐ Persistent Player (100 spins)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Wallet Connection Modal -->
    <div class="modal" id="walletModal">
        <div class="modal-content">
            <h2>🔗 Connect Wallet</h2>
            <p>Choose your Fractal Bitcoin wallet to start playing with real MoonYetis tokens:</p>
            
            <div style="display: grid; gap: 1rem; margin: 2rem 0;">
                <button class="modal-btn" onclick="window.connectWallet ? window.connectWallet() : console.log('Using modular wallet system')">
                    🦊 UniSat Wallet
                </button>
                <button class="modal-btn" onclick="window.connectWallet ? window.connectWallet() : console.log('Using modular wallet system')">
                    🅾️ OKX Wallet
                </button>
                <button class="modal-btn secondary" onclick="slotMachine.connectWallet('demo')">
                    🎮 Demo Mode (Free Play)
                </button>
            </div>
            
            <p style="font-size: 0.9rem; color: var(--gray-400);">
                Demo mode allows you to play without connecting a wallet using virtual tokens.
            </p>
            
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeModal('walletModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Insufficient Balance Modal -->
    <div class="modal" id="balanceModal">
        <div class="modal-content">
            <h2>⚠️ Insufficient Balance</h2>
            <p>You don't have enough MoonYetis tokens for this bet.</p>
            <p>Required: <span id="requiredAmount" style="color: var(--primary); font-weight: 700;"></span></p>
            <p>Available: <span id="availableAmount" style="color: var(--secondary); font-weight: 700;"></span></p>
            
            <div class="modal-buttons">
                <button class="modal-btn" onclick="reducebet()">Reduce Bet</button>
                <button class="modal-btn secondary" onclick="closeModal('balanceModal')">OK</button>
            </div>
        </div>
    </div>

    <!-- Big Win Modal -->
    <div class="modal" id="bigWinModal">
        <div class="modal-content">
            <h2 id="bigWinTitle">🎉 BIG WIN!</h2>
            <div style="font-size: 3rem; margin: 1rem 0;" id="bigWinEmoji">🚀</div>
            <p id="bigWinMessage">Congratulations on your amazing win!</p>
            <div style="font-size: 2rem; color: var(--accent); font-weight: 800; margin: 1rem 0;" id="bigWinAmount">
                0 MY
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn" onclick="closeModal('bigWinModal')">🎰 Continue Playing</button>
                <button class="modal-btn secondary" onclick="shareBigWin()">📱 Share Win</button>
            </div>
        </div>
    </div>

    <!-- Achievement Modal -->
    <div class="achievement" id="achievementModal">
        <h3 id="achievementTitle">🏆 Achievement Unlocked!</h3>
        <p id="achievementDesc">You've earned a new achievement!</p>
        <div style="font-size: 3rem; margin: 1rem 0;" id="achievementEmoji">🎯</div>
    </div>

    <!-- Win Celebration Effect -->
    <div class="win-celebration" id="winCelebration"></div>

    <script>
        // === GAME CONFIGURATION ===
        // NOTE: SYMBOLS now defined in slot-machine.js with image paths
        // Keeping SYMBOL_CLASSES for CSS compatibility
        const SYMBOLS = ['yeti', 'rocket', 'moon', 'coin', 'star', 'planet', 'alien', 'ufo'];
        const SYMBOL_CLASSES = {
            'yeti': 'symbol-yeti',
            'rocket': 'symbol-rocket', 
            'moon': 'symbol-moon',
            'coin': 'symbol-coin',
            'star': 'symbol-star',
            'planet': 'symbol-planet',
            'alien': 'symbol-alien',
            'ufo': 'symbol-ufo',
            'diamond': 'symbol-diamond'
        };
        const WILD_SYMBOL = 'yeti'; // Yeti symbol acts as wild
        const SCATTER_SYMBOL = 'moon'; // Moon symbol for free spins
        
        // Realistic paytable - more conservative payouts
        const PAYTABLE = {
            'yeti': { 5: 100, 4: 25, 3: 10 },   // Wild Yeti (reduced from 1000)
            'rocket': { 5: 50, 4: 15, 3: 5 },     // Rocket (reduced from 500)
            'moon': { 5: 30, 4: 8, 3: 3 },      // Moon/Scatter (reduced from 250)
            'coin': { 5: 20, 4: 6, 3: 2 },      // MoonYetis Coin (reduced from 100)
            'star': { 5: 15, 4: 4, 3: 1.5 },    // Star (reduced from 50)
            'planet': { 5: 10, 4: 3, 3: 1 },      // Planet (reduced from 25)
            'alien': { 5: 8, 4: 2, 3: 0.5 },     // Alien (reduced from 15)
            'ufo': { 5: 5, 4: 1.5, 3: 0.2 }    // UFO (reduced from 10)
        };

        // Realistic symbol frequencies - determines how often each symbol appears
        // Higher numbers = more frequent (worse symbols appear more often)
        const SYMBOL_WEIGHTS = {
            'yeti': 1,    // Wild - Very rare (1% chance)
            'rocket': 3,     // Rocket - Rare (3% chance)
            'moon': 4,     // Moon - Rare (4% chance) 
            'coin': 8,     // Coin - Uncommon (8% chance)
            'star': 15,    // Star - Common (15% chance)
            'planet': 20,    // Planet - Common (20% chance)
            'alien': 25,    // Alien - Very common (25% chance)
            'ufo': 24     // UFO - Very common (24% chance)
        };

        // === AUDIO SYSTEM ===
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.backgroundMusic = null;
                this.sounds = {};
                this.isInitialized = false;
                this.initAudio();
            }

            async initAudio() {
                try {
                    // Initialize Web Audio Context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create sound effects programmatically
                    this.createSounds();
                    this.isInitialized = true;
                    console.log('🎵 Audio system initialized');
                } catch (error) {
                    console.warn('⚠️ Audio not supported:', error);
                    gameState.audioEnabled = false;
                }
            }

            createSounds() {
                // Create various sound effects using Web Audio API
                this.sounds = {
                    spin: () => this.createSpinSound(),
                    win: () => this.createWinSound(),
                    bigWin: () => this.createBigWinSound(),
                    coinCollect: () => this.createCoinSound(),
                    freeSpins: () => this.createFreeSpinsSound(),
                    click: () => this.createClickSound(),
                    whoosh: () => this.createWhooshSound(),
                    celebration: () => this.createCelebrationSound()
                };
            }

            createSpinSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.5);
            }

            createWinSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(523, this.audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659, this.audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(784, this.audioContext.currentTime + 0.2); // G5
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.4, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }

            createBigWinSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                // Create multiple oscillators for a richer sound
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.type = 'sine';
                        const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6
                        oscillator.frequency.setValueAtTime(frequencies[i % frequencies.length], this.audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.5, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.4);
                    }, i * 100);
                }
            }

            createCoinSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }

            createFreeSpinsSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                // Magical chime sequence
                const notes = [523, 659, 784, 1047, 1319]; // C5 to E6
                notes.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                    }, index * 100);
                });
            }

            createClickSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.05);
            }

            createWhooshSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }

            createCelebrationSound() {
                if (!this.isInitialized || !gameState.audioEnabled) return;
                
                // Fireworks-like sound
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(Math.random() * 500 + 500, this.audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(gameState.sfxVolume * 0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                    }, i * 50);
                }
            }

            async startBackgroundMusic() {
                if (!this.isInitialized || !gameState.audioEnabled || gameState.backgroundMusicPlaying) return;
                
                try {
                    // Create ambient space music
                    this.createAmbientMusic();
                    gameState.backgroundMusicPlaying = true;
                    console.log('🎵 Background music started');
                } catch (error) {
                    console.warn('⚠️ Could not start background music:', error);
                }
            }

            createAmbientMusic() {
                if (!this.isInitialized) return;
                
                const playAmbientTone = () => {
                    if (!gameState.backgroundMusicPlaying || !gameState.audioEnabled) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = 'sine';
                    const baseFreq = 110; // A2
                    const harmonics = [1, 1.5, 2, 3, 4];
                    const freq = baseFreq * harmonics[Math.floor(Math.random() * harmonics.length)];
                    oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(gameState.musicVolume * 0.1, this.audioContext.currentTime + 2);
                    gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 8);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 8);
                    
                    // Schedule next tone
                    setTimeout(playAmbientTone, Math.random() * 3000 + 2000);
                };
                
                playAmbientTone();
            }

            stopBackgroundMusic() {
                gameState.backgroundMusicPlaying = false;
                console.log('🔇 Background music stopped');
            }

            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }

            toggleAudio() {
                gameState.audioEnabled = !gameState.audioEnabled;
                if (!gameState.audioEnabled) {
                    this.stopBackgroundMusic();
                }
                console.log(`🔊 Audio ${gameState.audioEnabled ? 'enabled' : 'disabled'}`);
            }

            setMasterVolume(volume) {
                gameState.masterVolume = Math.max(0, Math.min(1, volume));
                gameState.sfxVolume = gameState.masterVolume * 0.8;
                gameState.musicVolume = gameState.masterVolume * 0.3;
            }
        }

        // === BONUS GAMES SYSTEM ===
        class BonusGameManager {
            constructor(slotMachine) {
                this.slotMachine = slotMachine;
                this.currentGame = null;
                this.bonusContainer = null;
            }

            checkForBonusTrigger(results) {
                // Check for Moon Mission (3 rockets on any line)
                if (this.checkRocketBonus(results)) {
                    return { type: 'moon-mission', config: GAME_CONFIG.BONUS_TRIGGERS.MOON_MISSION };
                }
                
                // Check for Yeti Hunt (3 wilds anywhere)
                if (this.checkYetiBonus(results)) {
                    return { type: 'yeti-hunt', config: GAME_CONFIG.BONUS_TRIGGERS.YETI_HUNT };
                }
                
                // Check for Rocket Launch (5 UFOs anywhere)
                if (this.checkRocketLaunchBonus(results)) {
                    return { type: 'rocket-launch', config: GAME_CONFIG.BONUS_TRIGGERS.ROCKET_LAUNCH };
                }
                
                return null;
            }

            checkRocketBonus(results) {
                // Check all paylines for 3 consecutive rockets
                for (let lineIndex = 0; lineIndex < gameState.activeLines; lineIndex++) {
                    const line = PAYLINES[lineIndex];
                    const lineSymbols = line.map((pos, reel) => results[reel][pos]);
                    
                    let rocketCount = 0;
                    for (let i = 0; i < lineSymbols.length && rocketCount < 3; i++) {
                        if (lineSymbols[i] === 'rocket') {
                            rocketCount++;
                        } else {
                            rocketCount = 0; // Reset if not consecutive
                        }
                        
                        if (rocketCount >= 3) {
                            return true;
                        }
                    }
                }
                return false;
            }

            checkYetiBonus(results) {
                // Count wild yetis anywhere on the reels
                let yetiCount = 0;
                results.forEach(reel => {
                    reel.forEach(symbol => {
                        if (symbol === 'yeti') yetiCount++;
                    });
                });
                return yetiCount >= 3;
            }

            checkRocketLaunchBonus(results) {
                // Count UFOs anywhere on the reels
                let ufoCount = 0;
                results.forEach(reel => {
                    reel.forEach(symbol => {
                        if (symbol === 'ufo') ufoCount++;
                    });
                });
                return ufoCount >= 5;
            }

            async triggerBonus(bonusType, config) {
                gameState.isBonusMode = true;
                gameState.currentBonusType = bonusType;
                gameState.bonusWinnings = 0;
                gameState.bonusRoundsTriggered++;
                
                // Stop auto-spin during bonus
                gameState.isAutoSpin = false;
                gameState.autoSpinCount = 0;
                
                this.slotMachine.updateUI();
                
                // Play bonus trigger sound
                if (audioManager) audioManager.playSound('freeSpins');
                
                // Show bonus trigger animation
                await this.showBonusIntro(bonusType);
                
                // Start the specific bonus game
                switch (bonusType) {
                    case 'moon-mission':
                        this.currentGame = new MoonMissionGame(this, config);
                        break;
                    case 'yeti-hunt':
                        this.currentGame = new YetiHuntGame(this, config);
                        break;
                    case 'rocket-launch':
                        this.currentGame = new RocketLaunchGame(this, config);
                        break;
                }
                
                if (this.currentGame) {
                    await this.currentGame.start();
                }
            }

            async showBonusIntro(bonusType) {
                const bonusData = {
                    'moon-mission': {
                        title: '🚀 MOON MISSION BONUS!',
                        subtitle: 'Select planets to reveal hidden treasures!',
                        emoji: '🌌'
                    },
                    'yeti-hunt': {
                        title: '🏔️ YETI HUNT BONUS!',
                        subtitle: 'Catch the mysterious space yetis!',
                        emoji: '❄️'
                    },
                    'rocket-launch': {
                        title: '🛸 ROCKET LAUNCH BONUS!',
                        subtitle: 'Time your launch for maximum rewards!',
                        emoji: '🚀'
                    }
                };

                const data = bonusData[bonusType];
                
                return new Promise(resolve => {
                    const modal = document.createElement('div');
                    modal.className = 'modal show';
                    modal.innerHTML = `
                        <div class="modal-content bonus-intro">
                            <h2 style="font-size: 2.5rem; margin-bottom: 1rem; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${data.title}
                            </h2>
                            <div style="font-size: 4rem; margin: 2rem 0; animation: bonusGlow 2s ease-in-out infinite;">
                                ${data.emoji}
                            </div>
                            <p style="font-size: 1.3rem; color: var(--light); margin-bottom: 2rem;">
                                ${data.subtitle}
                            </p>
                            <div style="background: rgba(78, 205, 196, 0.1); padding: 1rem; border-radius: 12px; border: 1px solid var(--secondary); margin: 2rem 0;">
                                <p style="color: var(--secondary); font-weight: 600;">
                                    ✨ Guaranteed minimum win: ${GAME_CONFIG.BONUS_TRIGGERS[bonusType.toUpperCase().replace('-', '_')].baseWin}x bet!
                                </p>
                            </div>
                            <p style="color: var(--gray-400); font-size: 0.9rem;">
                                Bonus round starting in 3 seconds...
                            </p>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    setTimeout(() => {
                        modal.remove();
                        resolve();
                    }, 3000);
                });
            }

            async endBonus() {
                const totalWin = gameState.bonusWinnings;
                
                // Award winnings
                if (totalWin > 0) {
                    await walletManager.processPayout(totalWin);
                    gameState.totalWon += totalWin;
                    
                    if (totalWin > gameState.biggestWin) {
                        gameState.biggestWin = totalWin;
                    }
                    
                    this.slotMachine.addRecentWin(totalWin);
                }
                
                // Show bonus complete screen
                await this.showBonusComplete(totalWin);
                
                // Reset bonus state
                gameState.isBonusMode = false;
                gameState.currentBonusType = null;
                gameState.bonusWinnings = 0;
                gameState.bonusMultiplier = 1;
                
                // Clean up bonus container
                if (this.bonusContainer) {
                    this.bonusContainer.remove();
                    this.bonusContainer = null;
                }
                
                this.currentGame = null;
                this.slotMachine.updateUI();
                
                // Check for bonus achievements
                this.slotMachine.checkBonusAchievements();
            }

            async showBonusComplete(totalWin) {
                return new Promise(resolve => {
                    if (audioManager) audioManager.playSound('celebration');
                    
                    const modal = document.createElement('div');
                    modal.className = 'modal show';
                    modal.innerHTML = `
                        <div class="modal-content bonus-complete">
                            <h2 style="font-size: 2.2rem; margin-bottom: 1rem; color: var(--accent);">
                                🎉 BONUS COMPLETE!
                            </h2>
                            <div style="font-size: 3rem; margin: 1rem 0;">
                                ${totalWin > 50 ? '🏆' : totalWin > 25 ? '⭐' : '🎊'}
                            </div>
                            <p style="font-size: 1.2rem; color: var(--light); margin-bottom: 1rem;">
                                You earned from the bonus round:
                            </p>
                            <div style="font-size: 2.5rem; color: var(--secondary); font-weight: 800; margin: 1.5rem 0;">
                                ${totalWin} MY
                            </div>
                            <div style="background: rgba(255, 107, 53, 0.1); padding: 1rem; border-radius: 12px; border: 1px solid var(--primary); margin: 1.5rem 0;">
                                <p style="color: var(--primary); font-weight: 600;">
                                    🚀 ${totalWin >= 100 ? 'INCREDIBLE!' : totalWin >= 50 ? 'EXCELLENT!' : 'GREAT JOB!'}
                                </p>
                            </div>
                            <div class="modal-buttons">
                                <button class="modal-btn" onclick="this.parentElement.parentElement.parentElement.remove()">
                                    Continue Playing
                                </button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Auto close after 5 seconds
                    setTimeout(() => {
                        if (modal.parentNode) {
                            modal.remove();
                        }
                        resolve();
                    }, 5000);
                });
            }

            createBonusContainer() {
                this.bonusContainer = document.createElement('div');
                this.bonusContainer.className = 'bonus-game-container';
                this.bonusContainer.innerHTML = `
                    <div class="bonus-header">
                        <h2 id="bonusTitle">Bonus Round</h2>
                        <div class="bonus-stats">
                            <div class="bonus-stat">
                                <span class="bonus-stat-label">Winnings:</span>
                                <span class="bonus-stat-value" id="bonusWinnings">0 MY</span>
                            </div>
                            <div class="bonus-stat">
                                <span class="bonus-stat-label">Multiplier:</span>
                                <span class="bonus-stat-value" id="bonusMultiplier">1x</span>
                            </div>
                        </div>
                    </div>
                    <div class="bonus-game-area" id="bonusGameArea">
                        <!-- Bonus game content will be inserted here -->
                    </div>
                `;
                
                // Replace slot machine temporarily
                const slotMachine = document.querySelector('.slot-machine');
                slotMachine.style.display = 'none';
                slotMachine.parentNode.insertBefore(this.bonusContainer, slotMachine);
                
                return this.bonusContainer;
            }

            updateBonusUI() {
                if (this.bonusContainer) {
                    document.getElementById('bonusWinnings').textContent = `${gameState.bonusWinnings} MY`;
                    document.getElementById('bonusMultiplier').textContent = `${gameState.bonusMultiplier}x`;
                }
            }
        }

        // Create weighted symbol pool for realistic probabilities
        const WEIGHTED_SYMBOLS = [];
        Object.entries(SYMBOL_WEIGHTS).forEach(([symbol, weight]) => {
            for (let i = 0; i < weight; i++) {
                WEIGHTED_SYMBOLS.push(symbol);
            }
        });

        // Game settings
        const GAME_CONFIG = {
            RTP: 0.96,              // 96% Return to Player (4% house edge)
            MIN_BET: 10000,         // 10K MY minimum bet
            MAX_BET: 100000,        // 100K MY maximum bet
            MIN_LINES: 1,
            MAX_LINES: 25,
            NEAR_MISS_CHANCE: 0.15, // 15% chance of near miss for excitement
            FREE_SPINS_CHANCE: 0.02, // 2% chance of free spins
            VOLATILITY: 'medium',     // low, medium, high
            
            // Turbo mode timings
            NORMAL_REEL_DURATION: [800, 900, 1000, 1100, 1200],
            TURBO_REEL_DURATION: [300, 375, 450, 525, 600], // 3x faster
            NORMAL_EFFECT_DELAY: 800,
            TURBO_EFFECT_DELAY: 200, // 3x faster
            NORMAL_AUTO_DELAY: 1200,
            TURBO_AUTO_DELAY: 400, // Nearly 3x faster
            
            // Bonus round configurations
            BONUS_TRIGGERS: {
                MOON_MISSION: {
                    symbols: ['rocket', 'rocket', 'rocket'], // 3 rockets on any payline
                    chance: 0.008, // 0.8% chance
                    baseWin: 50 // Minimum guaranteed win
                },
                YETI_HUNT: {
                    symbols: ['yeti', 'yeti', 'yeti'], // 3 wilds anywhere
                    chance: 0.005, // 0.5% chance
                    baseWin: 75
                },
                ROCKET_LAUNCH: {
                    symbols: ['ufo', 'ufo', 'ufo', 'ufo', 'ufo'], // 5 UFOs anywhere
                    chance: 0.003, // 0.3% chance
                    baseWin: 100
                }
            }
        };

        const PAYLINES = [
            [1,1,1,1,1], [0,0,0,0,0], [2,2,2,2,2], // Horizontal lines
            [0,1,2,1,0], [2,1,0,1,2], // V patterns
            [1,0,1,2,1], [1,2,1,0,1], // Zig-zag patterns
            [0,0,1,2,2], [2,2,1,0,0], // Diagonal slopes
            [1,0,0,0,1], [1,2,2,2,1], // High-low patterns
            [0,1,1,1,0], [2,1,1,1,2], // Diamond patterns
            [0,2,0,2,0], [2,0,2,0,2], // Alternating patterns
            [1,1,0,1,1], [1,1,2,1,1], // Center focus patterns
            [0,1,0,1,0], [2,1,2,1,2], // Up-down patterns
            [0,0,2,0,0], [2,2,0,2,2], // Corner focus patterns
            [1,0,2,0,1], [1,2,0,2,1], // Cross patterns
            [0,2,1,2,0], [2,0,1,0,2], // Complex patterns
            [1,1,1,0,0], [1,1,1,2,2]  // Partial lines
        ];

        // === GAME STATE ===
        let gameState = {
            balance: 0,
            currentBet: 10000,      // 10K MY initial bet
            activeLines: 25,
            isSpinning: false,
            isAutoSpin: false,
            autoSpinCount: 0,
            connectedWallet: null,
            demoMode: false,
            
            // Free Spins Mode
            isFreeSpinsMode: false,
            freeSpinsRemaining: 0,
            freeSpinsMultiplier: 1,
            totalFreeSpinsWon: 0,
            
            // Bonus Rounds
            isBonusMode: false,
            currentBonusType: null, // 'moon-mission', 'yeti-hunt', 'rocket-launch'
            bonusProgress: 0,
            bonusWinnings: 0,
            bonusMultiplier: 1,
            
            // Audio & Turbo Settings
            audioEnabled: true,
            turboMode: false,
            masterVolume: 0.7,
            musicVolume: 0.3,
            sfxVolume: 0.8,
            backgroundMusicPlaying: false,
            
            // Stats
            totalSpins: 0,
            totalWagered: 0,
            totalWon: 0,
            biggestWin: 0,
            recentWins: [],
            achievements: new Set(),
            bonusRoundsTriggered: 0,
            
            // Current spin results
            reels: [[], [], [], [], []],
            winningLines: [],
            totalWinAmount: 0,
            
            // Cleanup tracking
            activeTimeouts: new Set(),
            activeIntervals: new Set(),
            particles: []
        };

        // === REAL BLOCKCHAIN INTEGRATION ===
        class BlockchainIntegration {
            constructor() {
                this.apiBase = '/api/blockchain';
                this.connectedWallet = null;
                this.walletType = null;
                this.accountInfo = null;
                this.isConnecting = false;
                this.gameSession = null;
                this.pendingTransactions = new Map();
                
                // Initialize WebSocket for real-time updates (disabled for now)
                // this.initializeWebSocket();
            }

            // Initialize WebSocket connection for real-time blockchain updates
            initializeWebSocket() {
                // Initialize reconnection counter if not exists
                if (!this.wsReconnectCount) {
                    this.wsReconnectCount = 0;
                }
                
                if (this.wsReconnectCount >= 3) {
                    console.warn('⚠️ WebSocket max reconnection attempts reached (3). WebSocket disabled.');
                    this.wsDisabled = true;
                    return;
                }
                
                // Skip WebSocket if disabled
                if (this.wsDisabled) {
                    return;
                }
                
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                
                try {
                    this.ws = new WebSocket(`${protocol}//${window.location.host}`);
                    
                    this.ws.onopen = () => {
                        console.log('🔗 Blockchain WebSocket connected');
                        this.wsReconnectCount = 0; // Reset counter on successful connection
                        this.ws.send(JSON.stringify({ type: 'ping' }));
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('WebSocket message error:', error);
                        }
                    };
                    
                    this.ws.onclose = (event) => {
                        if (this.wsDisabled) return;
                        
                        this.wsReconnectCount++;
                        console.log(`🔌 WebSocket disconnected (${this.wsReconnectCount}/3)`);
                        
                        if (this.wsReconnectCount < 3) {
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        } else {
                            console.warn('⚠️ WebSocket disabled after 3 failed attempts. Game will work without real-time updates.');
                            this.wsDisabled = true;
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        if (this.wsDisabled) return;
                        console.warn('WebSocket connection failed. Retrying...');
                    };
                    
                } catch (error) {
                    console.warn('WebSocket not supported or failed to initialize:', error);
                    this.wsDisabled = true;
                }
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'welcome':
                        console.log('🎰 Blockchain features available:', data.features);
                        break;
                    case 'transaction_update':
                        this.handleTransactionUpdate(data.transaction);
                        break;
                    case 'game_broadcast':
                        this.handleGameBroadcast(data.data);
                        break;
                }
            }

            // Connect to UniSat or OKX wallet
            async connectWallet(walletType) {
                if (this.isConnecting) return { success: false, error: 'Connection in progress' };
                
                try {
                    this.isConnecting = true;
                    
                    if (walletType === 'demo') {
                        return this.connectDemoMode();
                    }
                    
                    // Check if wallet extension is available
                    const walletProvider = this.getWalletProvider(walletType);
                    if (!walletProvider) {
                        throw new Error(`${walletType} wallet not installed`);
                    }

                    // Request wallet connection
                    const result = await this.requestWalletConnection(walletType, walletProvider);
                    if (!result.success) {
                        throw new Error(result.error);
                    }

                    // Authenticate with backend
                    const authResult = await this.authenticateWallet(result.address, result.publicKey, result.signature);
                    if (!authResult.success) {
                        throw new Error(authResult.error);
                    }

                    // Get account information
                    await this.updateAccountInfo();
                    
                    this.connectedWallet = result.address;
                    this.walletType = walletType;
                    gameState.connectedWallet = result.address;
                    gameState.demoMode = false;
                    gameState.realBlockchain = true;
                    
                    // Initialize game session
                    await this.initializeGameSession();
                    
                    this.showSuccessMessage(`Connected to ${walletType} wallet successfully!`);
                    return { success: true, address: result.address };
                    
                } catch (error) {
                    console.error('Wallet connection error:', error);
                    this.showErrorMessage(error.message);
                    return { success: false, error: error.message };
                } finally {
                    this.isConnecting = false;
                }
            }

            // Demo mode connection
            connectDemoMode() {
                this.connectedWallet = 'demo';
                this.walletType = 'demo';
                this.accountInfo = {
                    gameChips: 10000000,    // 10M MY for demo
                    walletAddress: 'demo_address',
                    totalDeposited: 0,
                    totalWithdrawn: 0
                };
                
                gameState.balance = 10000000;   // 10M MY for demo
                gameState.connectedWallet = 'demo';
                gameState.demoMode = true;
                gameState.realBlockchain = false;
                
                this.showSuccessMessage('Demo mode activated! 10,000,000 MY free chips loaded.');
                return { success: true, address: 'demo' };
            }

            // Get wallet provider object
            getWalletProvider(walletType) {
                switch (walletType) {
                    case 'unisat':
                        return window.unisat;
                    case 'okx':
                        return window.okxwallet?.bitcoin;
                    default:
                        return null;
                }
            }

            // Request wallet connection and signature
            async requestWalletConnection(walletType, provider) {
                try {
                    // Request account access
                    const accounts = await provider.requestAccounts();
                    if (!accounts || accounts.length === 0) {
                        throw new Error('No accounts available');
                    }

                    const address = accounts[0];
                    
                    // Get public key
                    const publicKey = await provider.getPublicKey();
                    
                    // Create message to sign for authentication
                    const message = `Connect to MoonYetis Slots\nAddress: ${address}\nTimestamp: ${Date.now()}`;
                    
                    // Request signature
                    const signature = await provider.signMessage(message);
                    
                    return {
                        success: true,
                        address,
                        publicKey,
                        signature,
                        message
                    };
                } catch (error) {
                    // Handle specific error codes
                    let errorMessage = 'Failed to connect wallet';
                    
                    if (error.code === 4001 || error.message?.includes('User rejected')) {
                        errorMessage = 'Connection cancelled by user';
                        console.log('👤 User cancelled wallet connection');
                    } else if (error.code === -32002) {
                        errorMessage = 'Wallet connection already pending';
                    } else if (error.message?.includes('not installed')) {
                        errorMessage = `${walletType} wallet not installed`;
                    } else {
                        console.error('Wallet connection error:', error);
                    }
                    
                    return {
                        success: false,
                        error: errorMessage,
                        code: error.code
                    };
                }
            }

            // Authenticate wallet with backend
            async authenticateWallet(address, publicKey, signature) {
                try {
                    const response = await fetch(`${this.apiBase}/wallet/connect`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            walletType: this.walletType,
                            address,
                            publicKey,
                            signature
                        })
                    });

                    const result = await response.json();
                    return result;
                } catch (error) {
                    return {
                        success: false,
                        error: 'Backend authentication failed'
                    };
                }
            }

            // Get account information from backend
            async updateAccountInfo() {
                try {
                    const response = await fetch(`${this.apiBase}/account/info`, {
                        headers: {
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        }
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.accountInfo = result.account;
                        gameState.balance = result.account.gameChips;
                        return result;
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    console.error('Failed to update account info:', error);
                    return { success: false, error: error.message };
                }
            }

            // Initialize provably fair game session
            async initializeGameSession(clientSeed = null) {
                try {
                    const response = await fetch(`${this.apiBase}/game/session/init`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        },
                        body: JSON.stringify({ clientSeed })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.gameSession = result.session;
                        console.log('🎮 Provably fair game session initialized');
                        return result;
                    }
                } catch (error) {
                    console.error('Failed to initialize game session:', error);
                }
            }

            // Place bet and play slot round (real blockchain)
            async playSlotRound(betAmount) {
                if (gameState.demoMode) {
                    return this.playDemoRound(betAmount);
                }

                try {
                    if (!this.connectedWallet) {
                        throw new Error('Wallet not connected');
                    }

                    if (this.accountInfo.gameChips < betAmount) {
                        throw new Error('Insufficient game chips');
                    }

                    // Create client seed for provably fair
                    const clientSeed = Math.random().toString(36).substring(2, 15);

                    const response = await fetch(`${this.apiBase}/game/play`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        },
                        body: JSON.stringify({
                            betAmount,
                            clientSeed
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        // Update local balance
                        await this.updateAccountInfo();
                        
                        // Broadcast game update via WebSocket
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify({
                                type: 'game_update',
                                gameData: {
                                    walletAddress: this.connectedWallet,
                                    betAmount,
                                    winAmount: result.gameRound.winAmount,
                                    isWin: result.gameRound.isWin
                                }
                            }));
                        }
                        
                        return {
                            success: true,
                            reels: this.formatReelsFromBlockchain(result.gameRound.slotResults),
                            winAmount: result.gameRound.winAmount,
                            betAmount: result.gameRound.betAmount,
                            isWin: result.gameRound.isWin,
                            multiplier: result.gameRound.multiplier,
                            provablyFair: result.provablyFair,
                            roundId: result.gameRound.roundId
                        };
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    console.error('Slot round error:', error);
                    this.showErrorMessage(error.message);
                    return { success: false, error: error.message };
                }
            }

            // Demo mode slot round
            async playDemoRound(betAmount) {
                if (gameState.balance < betAmount) {
                    return { success: false, error: 'Insufficient balance' };
                }

                return new Promise((resolve) => {
                    setTimeout(() => {
                        // Simulate slot results
                        const reels = [];
                        const symbols = SYMBOLS;
                        
                        for (let i = 0; i < 5; i++) {
                            const reel = [];
                            for (let j = 0; j < 3; j++) {
                                reel.push(symbols[Math.floor(Math.random() * symbols.length)]);
                            }
                            reels.push(reel);
                        }
                        
                        // Simulate win
                        const winAmount = Math.random() > 0.7 ? betAmount * (1 + Math.random() * 10) : 0;
                        
                        gameState.balance -= betAmount;
                        gameState.balance += Math.floor(winAmount);
                        
                        resolve({
                            success: true,
                            reels,
                            winAmount: Math.floor(winAmount),
                            betAmount,
                            isWin: winAmount > 0,
                            multiplier: winAmount > 0 ? winAmount / betAmount : 0,
                            timestamp: new Date().toISOString()
                        });
                    }, 1000);
                });
            }

            // Format blockchain slot results to frontend format
            formatReelsFromBlockchain(blockchainResults) {
                const symbols = [...SYMBOLS, 'diamond'];
                const reels = [];
                
                // Convert blockchain results (3x5 grid) to frontend format
                for (let col = 0; col < 5; col++) {
                    const reel = [];
                    for (let row = 0; row < 3; row++) {
                        const index = row * 5 + col;
                        const symbolIndex = blockchainResults.flat[index];
                        reel.push(symbols[symbolIndex] || 'yeti');
                    }
                    reels.push(reel);
                }
                
                return reels;
            }

            // Process deposit
            async processDeposit(tokenAmount, txHash) {
                try {
                    const response = await fetch(`${this.apiBase}/deposit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        },
                        body: JSON.stringify({
                            tokenAmount,
                            txHash
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        await this.updateAccountInfo();
                        this.showSuccessMessage(`Deposit successful! ${result.account.gameChips} chips received.`);
                        return result;
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    this.showErrorMessage(`Deposit failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            }

            // Process withdrawal
            async processWithdrawal(chipAmount, toAddress) {
                try {
                    const response = await fetch(`${this.apiBase}/withdraw`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        },
                        body: JSON.stringify({
                            chipAmount,
                            toAddress: toAddress || this.connectedWallet
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        await this.updateAccountInfo();
                        this.showSuccessMessage(`Withdrawal initiated! ${result.withdrawal.tokenAmount} MOONYETIS tokens.`);
                        return result;
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    this.showErrorMessage(`Withdrawal failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            }

            // Get MOONYETIS token balance
            async getTokenBalance() {
                try {
                    const response = await fetch(`${this.apiBase}/wallet/balance`, {
                        headers: {
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        }
                    });

                    const result = await response.json();
                    return result;
                } catch (error) {
                    console.error('Failed to get token balance:', error);
                    return { success: false, error: error.message };
                }
            }

            // Disconnect wallet
            async disconnectWallet() {
                try {
                    if (this.connectedWallet && !gameState.demoMode) {
                        await fetch(`${this.apiBase}/wallet/disconnect`, {
                            method: 'POST',
                            headers: {
                                'X-Wallet-Address': this.connectedWallet,
                                'X-Wallet-Signature': 'authenticated'
                            }
                        });
                    }
                    
                    this.connectedWallet = null;
                    this.walletType = null;
                    this.accountInfo = null;
                    this.gameSession = null;
                    
                    gameState.balance = 0;
                    gameState.connectedWallet = null;
                    gameState.demoMode = false;
                    gameState.realBlockchain = false;
                    
                    this.showSuccessMessage('Wallet disconnected successfully');
                } catch (error) {
                    console.error('Disconnect error:', error);
                }
            }

            // Show success message
            showSuccessMessage(message) {
                console.log('✅', message);
                // Add UI notification here
            }

            // Show error message
            showErrorMessage(message) {
                console.error('❌', message);
                // Add UI notification here
            }

            // Handle transaction updates from WebSocket
            handleTransactionUpdate(transaction) {
                console.log('📡 Transaction update:', transaction);
                if (transaction.status === 'completed') {
                    this.updateAccountInfo();
                }
            }

            // Handle game broadcasts from other players
            handleGameBroadcast(gameData) {
                console.log('🎮 Game broadcast:', gameData);
                // Add multiplayer features here
            }

            // Get provably fair verification
            async verifyGameRound(roundId) {
                try {
                    const response = await fetch(`${this.apiBase}/provably-fair/verify/${roundId}`);
                    const result = await response.json();
                    return result;
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // Get player statistics
            async getPlayerStats() {
                try {
                    const response = await fetch(`${this.apiBase}/game/stats`, {
                        headers: {
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        }
                    });
                    return await response.json();
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // Get global leaderboard
            async getLeaderboard(sortBy = 'total_wagered', limit = 20) {
                try {
                    const response = await fetch(`${this.apiBase}/leaderboard?sort=${sortBy}&limit=${limit}`);
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                    return { success: false, error: error.message };
                }
            }

            // Update player leaderboard stats
            async updateLeaderboardStats(betAmount, winAmount, isWin) {
                if (!this.connectedWallet) return;
                
                try {
                    const response = await fetch(`${this.apiBase}/leaderboard/update`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Wallet-Address': this.connectedWallet,
                            'X-Wallet-Signature': 'authenticated'
                        },
                        body: JSON.stringify({
                            wallet_address: this.connectedWallet,
                            bet_amount: betAmount,
                            win_amount: winAmount,
                            is_win: isWin
                        })
                    });
                    return await response.json();
                } catch (error) {
                    console.error('Error updating leaderboard:', error);
                    return { success: false, error: error.message };
                }
            }

            // Get specific player leaderboard stats
            async getPlayerLeaderboardStats(walletAddress) {
                try {
                    const response = await fetch(`${this.apiBase}/leaderboard/player/${walletAddress}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching player leaderboard stats:', error);
                    return { success: false, error: error.message };
                }
            }
        }

        // Legacy WalletManager wrapper for backward compatibility
        class WalletManager {
            constructor() {
                this.blockchain = new BlockchainIntegration();
            }

            async connectWallet(walletType) {
                return await this.blockchain.connectWallet(walletType);
            }

            async placeBet(amount) {
                const result = await this.blockchain.playSlotRound(amount);
                if (result.success) {
                    return { success: true, txHash: result.roundId || 'demo_tx_' + Date.now() };
                }
                return result;
            }

            async processPayout(amount) {
                // Payout is handled automatically by playSlotRound
                return { success: true, txHash: 'auto_payout_' + Date.now() };
            }

            disconnectWallet() {
                this.blockchain.disconnectWallet();
            }

            get connectedWallet() {
                return this.blockchain.connectedWallet;
            }

            get balance() {
                return gameState.balance;
            }
        }

        const walletManager = new WalletManager();

        // === GAME MECHANICS ===
        class SlotMachine {
            constructor() {
                // this.initializeReels(); // REMOVED - handled by slot-machine.js module
                this.bindEvents();
                this.updateUI();
                this.startBackgroundEffects();
                
                // Initialize audio with fallback
                try {
                    audioManager = new AudioManager();
                } catch (error) {
                    console.warn('AudioManager initialization failed:', error);
                    // Create mock audioManager to prevent crashes
                    audioManager = {
                        playSound: () => {},
                        stopSound: () => {},
                        setMuted: () => {},
                        setVolume: () => {}
                    };
                }
                
                // Initialize bonus game manager
                this.bonusManager = new BonusGameManager(this);
                
                // Cleanup interval to prevent memory leaks
                this.cleanupInterval = setInterval(() => {
                    this.performCleanup();
                }, 30000); // Clean every 30 seconds
            }

            bindEvents() {
                // Spin button
                document.getElementById('spinBtn').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.spin();
                });
                
                // AUTO button removed - manual spinning only
                
                // Bet controls
                document.getElementById('betUp').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.adjustBet(1);
                });
                document.getElementById('betDown').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.adjustBet(-1);
                });
                
                // Lines controls
                document.getElementById('linesUp').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.adjustLines(1);
                });
                document.getElementById('linesDown').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.adjustLines(-1);
                });
                
                // Audio controls
                document.getElementById('audioToggle').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    if (audioManager) audioManager.setMasterVolume(volume);
                });
                
                // Settings panel toggles
                document.getElementById('turboToggle').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.toggleTurboMode();
                });
                
                document.getElementById('audioToggleSwitch').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                document.getElementById('musicToggle').addEventListener('click', () => {
                    if (audioManager) audioManager.playSound('click');
                    this.toggleBackgroundMusic();
                });
                
                document.getElementById('masterVolumeSlider').addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    if (audioManager) audioManager.setMasterVolume(volume);
                    document.getElementById('volumeSlider').value = e.target.value;
                });
                
                // Wallet connection (REMOVED - consolidated below)
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !gameState.isSpinning) {
                        e.preventDefault();
                        this.spin();
                    }
                    if (e.key === 'T' || e.key === 't') {
                        this.toggleTurboMode();
                    }
                    if (e.key === 'M' || e.key === 'm') {
                        this.toggleAudio();
                    }
                });

                // Leaderboard sort dropdown
                const leaderboardSort = document.getElementById('leaderboardSort');
                if (leaderboardSort) {
                    leaderboardSort.addEventListener('change', (e) => {
                        if (audioManager) audioManager.playSound('click');
                        this.loadLeaderboard(e.target.value);
                    });
                }
            }

            toggleTurboMode() {
                gameState.turboMode = !gameState.turboMode;
                
                const body = document.body;
                const turboToggle = document.getElementById('turboToggle');
                const turboBtn = document.getElementById('turboBtn');
                const slotMachine = document.querySelector('.slot-machine');
                
                if (gameState.turboMode) {
                    body.classList.add('turbo-mode');
                    turboToggle.classList.add('active');
                    turboBtn.style.background = 'var(--secondary)';
                    document.getElementById('turboText').textContent = '⚡ TURBO ON';
                    
                    // Add turbo indicator
                    if (!document.querySelector('.turbo-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'turbo-indicator';
                        indicator.textContent = '⚡ TURBO MODE';
                        slotMachine.appendChild(indicator);
                    }
                    
                    if (audioManager) audioManager.playSound('whoosh');
                    this.showAchievement('⚡ Turbo Mode Activated!', 'Spins are now 3x faster!');
                } else {
                    body.classList.remove('turbo-mode');
                    turboToggle.classList.remove('active');
                    turboBtn.style.background = 'var(--accent)';
                    document.getElementById('turboText').textContent = '⚡ TURBO';
                    
                    // Remove turbo indicator
                    const indicator = document.querySelector('.turbo-indicator');
                    if (indicator) indicator.remove();
                }
                
                console.log(`⚡ Turbo mode ${gameState.turboMode ? 'activated' : 'deactivated'}`);
            }

            toggleAudio() {
                if (audioManager) audioManager.toggleAudio();
                
                const audioToggle = document.getElementById('audioToggle');
                const audioToggleSwitch = document.getElementById('audioToggleSwitch');
                
                if (gameState.audioEnabled) {
                    audioToggle.textContent = '🔊';
                    audioToggle.classList.remove('muted');
                    audioToggleSwitch.classList.add('active');
                    if (audioManager) audioManager.playSound('click');
                } else {
                    audioToggle.textContent = '🔇';
                    audioToggle.classList.add('muted');
                    audioToggleSwitch.classList.remove('active');
                }
            }

            toggleBackgroundMusic() {
                const musicToggle = document.getElementById('musicToggle');
                
                if (gameState.backgroundMusicPlaying) {
                    if (audioManager) audioManager.stopBackgroundMusic();
                    musicToggle.classList.remove('active');
                } else {
                    if (audioManager) audioManager.startBackgroundMusic();
                    musicToggle.classList.add('active');
                }
            }

            performCleanup() {
                // Clean up old particles
                const particlesContainer = document.getElementById('particles');
                if (particlesContainer && particlesContainer.children.length > 50) {
                    // Remove oldest particles
                    while (particlesContainer.children.length > 20) {
                        particlesContainer.removeChild(particlesContainer.firstChild);
                    }
                }

                // Clean up old overlays
                const oldOverlays = document.querySelectorAll('#freeSpinOverlay');
                oldOverlays.forEach((overlay, index) => {
                    if (index > 0) { // Keep only the first one
                        overlay.remove();
                    }
                });

                // Clean up old confetti
                const celebration = document.getElementById('winCelebration');
                if (celebration && celebration.children.length > 0) {
                    celebration.innerHTML = '';
                }

                // Clear expired timeouts
                gameState.activeTimeouts.forEach(timeoutId => {
                    if (timeoutId && typeof timeoutId === 'number') {
                        clearTimeout(timeoutId);
                    }
                });
                gameState.activeTimeouts.clear();

                console.log('🧹 Cleanup performed - Memory optimized');
            }

            // Safe timeout wrapper
            safeTimeout(callback, delay) {
                const timeoutId = setTimeout(() => {
                    gameState.activeTimeouts.delete(timeoutId);
                    callback();
                }, delay);
                gameState.activeTimeouts.add(timeoutId);
                return timeoutId;
            }

            // Safe interval wrapper  
            safeInterval(callback, delay) {
                const intervalId = setInterval(callback, delay);
                gameState.activeIntervals.add(intervalId);
                return intervalId;
            }

            // Clear all active timeouts and intervals
            clearAllTimers() {
                gameState.activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                gameState.activeTimeouts.clear();
                
                gameState.activeIntervals.forEach(intervalId => clearInterval(intervalId));
                gameState.activeIntervals.clear();
            }

            // initializeReels() REMOVED - handled by slot-machine.js module

            bindEvents() {
                // Spin button
                document.getElementById('spinBtn').addEventListener('click', () => this.spin());
                
                // Auto spin button
                // document.getElementById('autoSpinBtn').addEventListener('click', () => this.toggleAutoSpin()); // REMOVED - duplicate
                
                // Bet controls
                document.getElementById('betUp').addEventListener('click', () => this.adjustBet(1));
                document.getElementById('betDown').addEventListener('click', () => this.adjustBet(-1));
                
                // Lines controls
                document.getElementById('linesUp').addEventListener('click', () => this.adjustLines(1));
                document.getElementById('linesDown').addEventListener('click', () => this.adjustLines(-1));
                
                // Wallet connection (REMOVED - consolidated below)
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !gameState.isSpinning) {
                        e.preventDefault();
                        this.spin();
                    }
                });
            }

            async spin() {
                if (gameState.isSpinning) {
                    console.warn('⚠️ Spin already in progress, ignoring request');
                    return;
                }
                
                if (!gameState.connectedWallet) {
                    this.showWalletModal();
                    return;
                }

                try {
                    const totalBet = gameState.currentBet * gameState.activeLines;
                    
                    // Only check balance and place bet if NOT in free spins mode
                    if (!gameState.isFreeSpinsMode) {
                        if (gameState.balance < totalBet) {
                            this.showInsufficientBalanceModal(totalBet);
                            return;
                        }

                        gameState.isSpinning = true;
                        this.updateUI();

                        // Place bet transaction
                        const betResult = await walletManager.placeBet(totalBet);
                        if (!betResult.success) {
                            gameState.isSpinning = false;
                            this.showError(betResult.error);
                            return;
                        }

                        // Update stats
                        gameState.totalSpins++;
                        gameState.totalWagered += totalBet;
                    } else {
                        // Free spin - no bet required
                        gameState.isSpinning = true;
                        gameState.freeSpinsRemaining--;
                        this.updateUI();
                        this.showFreeSpinInfo();
                    }

                    // Animate reels spinning
                    await this.animateReels();

                    // Generate results
                    const results = this.generateSpinResults();
                    gameState.reels = results;

                    // Display results
                    this.displayResults(results);

                    // Check for wins
                    const winResult = this.checkWins(results);
                    gameState.winningLines = winResult.lines;
                    gameState.totalWinAmount = winResult.totalWin;

                    // Apply free spins multiplier
                    if (gameState.isFreeSpinsMode && winResult.totalWin > 0) {
                        winResult.totalWin *= gameState.freeSpinsMultiplier;
                        gameState.totalWinAmount = winResult.totalWin;
                    }

                    if (winResult.totalWin > 0) {
                        // Process payout
                        await walletManager.processPayout(winResult.totalWin);
                        
                        // Update stats
                        gameState.totalWon += winResult.totalWin;
                        if (gameState.isFreeSpinsMode) {
                            gameState.totalFreeSpinsWon += winResult.totalWin;
                        }
                        
                        if (winResult.totalWin > gameState.biggestWin) {
                            gameState.biggestWin = winResult.totalWin;
                        }

                        // Add to recent wins
                        this.addRecentWin(winResult.totalWin);

                        // Show win effects with audio
                        this.showWinEffects(winResult.totalWin);

                        // Check for achievements
                        this.checkAchievements(winResult);
                        
                        // Update leaderboard stats for wins
                        await this.updatePlayerLeaderboardStats(totalBet, winResult.totalWin, true);
                    } else {
                        // Update leaderboard stats for losses (no win)
                        await this.updatePlayerLeaderboardStats(totalBet, 0, false);
                    }

                    // Check for special features (only if not already in free spins)
                    if (!gameState.isFreeSpinsMode) {
                        this.checkSpecialFeatures(results);
                    }

                    // Check if free spins mode should end
                    if (gameState.isFreeSpinsMode && gameState.freeSpinsRemaining <= 0) {
                        this.endFreeSpinsMode();
                    }

                    gameState.isSpinning = false;
                    this.updateUI();

                    // Continue auto spin or free spins with safety checks and turbo timing
                    const continuationDelay = gameState.turboMode ? 
                        GAME_CONFIG.TURBO_AUTO_DELAY : 
                        GAME_CONFIG.NORMAL_AUTO_DELAY;
                    
                    if (gameState.isFreeSpinsMode && gameState.freeSpinsRemaining > 0) {
                        // Continue free spins automatically
                        this.safeTimeout(() => {
                            if (gameState.isFreeSpinsMode && !gameState.isSpinning) {
                                this.spin();
                            }
                        }, gameState.turboMode ? 400 : 800); // Faster in turbo mode
                    } else if (gameState.isAutoSpin && gameState.autoSpinCount > 0 && !gameState.isFreeSpinsMode) {
                        // Use our custom auto-spin continuation system
                        this.safeTimeout(() => {
                            if (typeof window.autoSpinContinuation === 'function') {
                                console.log('🔄 Triggering custom auto-spin continuation...');
                                window.autoSpinContinuation();
                            } else {
                                // Fallback to original system
                                gameState.autoSpinCount--;
                                if (gameState.isAutoSpin && !gameState.isSpinning && !gameState.isFreeSpinsMode) {
                                    this.spin();
                                }
                            }
                        }, continuationDelay);
                    }

                } catch (error) {
                    console.error('❌ Error in spin function:', error);
                    gameState.isSpinning = false;
                    this.updateUI();
                    
                    // Trigger auto-spin continuation even after error
                    if (gameState.isAutoSpin && gameState.autoSpinCount > 0 && typeof window.autoSpinContinuation === 'function') {
                        console.log('🔄 Triggering auto-spin continuation after error...');
                        setTimeout(() => {
                            window.autoSpinContinuation();
                        }, 1000);
                    }
                }
            }

            async animateReels() {
                const reels = document.querySelectorAll('.reel');
                const spinDurations = gameState.turboMode ? 
                    GAME_CONFIG.TURBO_REEL_DURATION : 
                    GAME_CONFIG.NORMAL_REEL_DURATION;

                // Play spin sound
                if (audioManager) audioManager.playSound('spin');

                // Start all reels spinning
                reels.forEach((reel, index) => {
                    reel.classList.add('spinning');
                });

                // Stop reels one by one
                for (let i = 0; i < reels.length; i++) {
                    await new Promise(resolve => {
                        setTimeout(() => {
                            reels[i].classList.remove('spinning');
                            // Play stop sound for each reel
                            if (audioManager) audioManager.playSound('click');
                            resolve();
                        }, spinDurations[i]);
                    });
                }
            }

            generateSpinResults() {
                const results = [];
                
                // Apply RTP logic - occasionally generate losing spins to maintain house edge
                const shouldForceResult = Math.random() < 0.1; // 10% of spins are "managed"
                const currentRTP = this.calculateCurrentRTP();
                
                // If RTP is too high, increase chance of losing spin
                const shouldForceLoss = currentRTP > GAME_CONFIG.RTP + 0.05 && shouldForceResult;
                
                // If RTP is too low, increase chance of winning spin  
                const shouldForceWin = currentRTP < GAME_CONFIG.RTP - 0.05 && shouldForceResult;
                
                for (let reel = 0; reel < 5; reel++) {
                    const reelResults = [];
                    for (let row = 0; row < 3; row++) {
                        let symbol;
                        
                        if (shouldForceLoss && reel < 3) {
                            // Force losing symbols on first 3 reels
                            symbol = this.getRandomLowValueSymbol();
                        } else if (shouldForceWin && Math.random() < 0.3) {
                            // Slightly increase chance of good symbols
                            symbol = this.getRandomHighValueSymbol();
                        } else {
                            // Normal weighted random selection
                            symbol = this.getWeightedRandomSymbol();
                        }
                        
                        reelResults.push(symbol);
                    }
                    results.push(reelResults);
                }
                
                // Apply near-miss logic for excitement (but no payout)
                if (Math.random() < GAME_CONFIG.NEAR_MISS_CHANCE && !shouldForceWin) {
                    results = this.generateNearMiss(results);
                }
                
                return results;
            }

            getWeightedRandomSymbol() {
                const randomIndex = Math.floor(Math.random() * WEIGHTED_SYMBOLS.length);
                return WEIGHTED_SYMBOLS[randomIndex];
            }

            getRandomLowValueSymbol() {
                const lowValueSymbols = ['ufo', 'alien', 'planet'];
                return lowValueSymbols[Math.floor(Math.random() * lowValueSymbols.length)];
            }

            getRandomHighValueSymbol() {
                const highValueSymbols = ['coin', 'star', 'moon', 'rocket'];
                return highValueSymbols[Math.floor(Math.random() * highValueSymbols.length)];
            }

            generateNearMiss(results) {
                // Create "near miss" - almost winning but not quite
                if (Math.random() < 0.5) {
                    // Near miss: 2 matching symbols in first positions, different 3rd
                    const symbol = this.getRandomHighValueSymbol();
                    results[0][1] = symbol; // Middle row, first reel
                    results[1][1] = symbol; // Middle row, second reel
                    // Third reel gets a different symbol
                    do {
                        results[2][1] = this.getWeightedRandomSymbol();
                    } while (results[2][1] === symbol);
                }
                return results;
            }

            calculateCurrentRTP() {
                if (gameState.totalWagered === 0) return GAME_CONFIG.RTP;
                return gameState.totalWon / gameState.totalWagered;
            }

            displayResults(results) {
                for (let reel = 0; reel < 5; reel++) {
                    const reelElement = document.getElementById(`reel-${reel}`);
                    const symbols = reelElement.querySelectorAll('.symbol');
                    
                    // Update visible symbols
                    for (let row = 0; row < 3; row++) {
                        if (symbols[row + 3]) { // Show symbols 3,4,5 (middle of strip)
                            const symbolElement = symbols[row + 3];
                            const symbolName = results[reel][row];
                            
                            // Clear previous symbol classes
                            Object.values(SYMBOL_CLASSES).forEach(cls => {
                                symbolElement.classList.remove(cls);
                            });
                            
                            // Add new symbol class
                            if (SYMBOL_CLASSES[symbolName]) {
                                symbolElement.classList.add(SYMBOL_CLASSES[symbolName]);
                            }
                            
                            // Clear text content since we're using CSS backgrounds
                            symbolElement.textContent = '';
                        }
                    }
                }
            }

            checkWins(results) {
                let totalWin = 0;
                const winningLines = [];

                for (let lineIndex = 0; lineIndex < gameState.activeLines; lineIndex++) {
                    const line = PAYLINES[lineIndex];
                    const lineSymbols = line.map((pos, reel) => results[reel][pos]);
                    
                    const winResult = this.checkLine(lineSymbols, lineIndex);
                    if (winResult.win > 0) {
                        totalWin += winResult.win;
                        winningLines.push({
                            line: lineIndex,
                            symbols: lineSymbols,
                            positions: line,
                            win: winResult.win,
                            count: winResult.count,
                            symbol: winResult.symbol
                        });
                    }
                }

                return { totalWin, lines: winningLines };
            }

            checkLine(symbols, lineIndex) {
                let count = 1;
                let currentSymbol = symbols[0];
                
                // Handle wild substitutions
                if (currentSymbol === WILD_SYMBOL) {
                    // Find first non-wild symbol or use wild
                    for (let i = 1; i < symbols.length; i++) {
                        if (symbols[i] !== WILD_SYMBOL) {
                            currentSymbol = symbols[i];
                            break;
                        }
                    }
                }

                // Count consecutive symbols (with wild substitution)
                for (let i = 1; i < symbols.length; i++) {
                    if (symbols[i] === currentSymbol || symbols[i] === WILD_SYMBOL || currentSymbol === WILD_SYMBOL) {
                        count++;
                    } else {
                        break;
                    }
                }

                // Calculate win
                let win = 0;
                if (count >= 3 && PAYTABLE[currentSymbol]) {
                    const multiplier = PAYTABLE[currentSymbol][count] || 0;
                    win = gameState.currentBet * multiplier;
                }

                return { win, count, symbol: currentSymbol };
            }

            checkSpecialFeatures(results) {
                // Check for scatter symbols (free spins) - only if not in bonus mode
                if (!gameState.isBonusMode) {
                    let scatterCount = 0;
                    results.forEach(reel => {
                        reel.forEach(symbol => {
                            if (symbol === SCATTER_SYMBOL) scatterCount++;
                        });
                    });

                    if (scatterCount >= 3) {
                        this.triggerFreeSpins(scatterCount);
                        return; // Don't check bonus if free spins triggered
                    }

                    // Check for bonus round triggers
                    const bonusTrigger = this.bonusManager.checkForBonusTrigger(results);
                    if (bonusTrigger) {
                        this.safeTimeout(() => {
                            this.bonusManager.triggerBonus(bonusTrigger.type, bonusTrigger.config);
                        }, gameState.turboMode ? 1000 : 2000);
                        return;
                    }
                }
            }

            triggerFreeSpins(scatterCount) {
                const freeSpins = scatterCount === 3 ? 10 : scatterCount === 4 ? 15 : 20; // 3=10, 4=15, 5=20 free spins
                const multiplier = scatterCount >= 4 ? 2 : 1; // 2x multiplier for 4+ scatters
                
                this.showAchievement('🌙 Free Spins Triggered!', `${freeSpins} free spins with ${multiplier}x multiplier!`);
                
                setTimeout(() => {
                    this.startFreeSpinsMode(freeSpins, multiplier);
                }, 2000);
            }

            startFreeSpinsMode(freeSpins, multiplier = 1) {
                gameState.isFreeSpinsMode = true;
                gameState.freeSpinsRemaining = freeSpins;
                gameState.freeSpinsMultiplier = multiplier;
                gameState.totalFreeSpinsWon = 0;
                
                // Stop auto spin during free spins
                gameState.isAutoSpin = false;
                gameState.autoSpinCount = 0;
                
                this.updateUI();
                this.showFreeSpinsModal(freeSpins, multiplier);
                
                // Start first free spin automatically after modal
                setTimeout(() => {
                    this.closeModal('freeSpinsModal');
                    setTimeout(() => this.spin(), 1000);
                }, 3000);
            }

            showFreeSpinsModal(freeSpins, multiplier) {
                // Create modal if it doesn't exist
                let modal = document.getElementById('freeSpinsModal');
                if (!modal) {
                    modal = this.createFreeSpinsModal();
                }
                
                document.getElementById('freeSpinsTitle').textContent = '🌙 FREE SPINS ACTIVATED!';
                document.getElementById('freeSpinsCount').textContent = freeSpins;
                document.getElementById('freeSpinsMultiplier').textContent = multiplier + 'x';
                
                modal.classList.add('show');
            }

            createFreeSpinsModal() {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'freeSpinsModal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2 id="freeSpinsTitle">🌙 FREE SPINS!</h2>
                        <div style="font-size: 4rem; margin: 1rem 0;">🎊</div>
                        <p>You've triggered <strong><span id="freeSpinsCount">10</span> FREE SPINS</strong></p>
                        <p>with <strong><span id="freeSpinsMultiplier">1</span> MULTIPLIER</strong></p>
                        <div style="margin: 2rem 0; padding: 1rem; background: rgba(78, 205, 196, 0.1); border-radius: 12px; border: 1px solid var(--secondary);">
                            <p style="color: var(--secondary); font-weight: 600;">✨ No bets required - All spins are FREE!</p>
                        </div>
                        <p style="color: var(--gray-400); font-size: 0.9rem;">Free spins will start automatically...</p>
                    </div>
                `;
                document.body.appendChild(modal);
                return modal;
            }

            showFreeSpinInfo() {
                // Show free spin counter overlay
                let overlay = document.getElementById('freeSpinOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'freeSpinOverlay';
                    overlay.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(78, 205, 196, 0.9);
                        color: var(--dark);
                        padding: 1rem 2rem;
                        border-radius: 15px;
                        font-weight: 800;
                        font-size: 1.2rem;
                        z-index: 1000;
                        border: 2px solid var(--secondary);
                        animation: fadeInOut 2s ease;
                    `;
                    document.querySelector('.slot-machine').appendChild(overlay);
                }
                
                overlay.textContent = `🌙 FREE SPIN ${gameState.freeSpinsRemaining + 1 - gameState.freeSpinsRemaining} • ${gameState.freeSpinsRemaining} remaining`;
                overlay.style.display = 'block';
                
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 2000);
            }

            endFreeSpinsMode() {
                const totalWon = gameState.totalFreeSpinsWon;
                
                // Reset free spins state
                gameState.isFreeSpinsMode = false;
                gameState.freeSpinsRemaining = 0;
                gameState.freeSpinsMultiplier = 1;
                
                this.updateUI();
                
                // Show free spins summary
                setTimeout(() => {
                    this.showFreeSpinsSummary(totalWon);
                }, 1000);
                
                // Check for free spins achievement
                if (totalWon > 0 && !gameState.achievements.has('free-spins-winner')) {
                    gameState.achievements.add('free-spins-winner');
                    setTimeout(() => {
                        this.showAchievement('🎊 Free Spins Master', 'You won during free spins!');
                        this.updateAchievementsDisplay();
                    }, 3000);
                }
            }

            showFreeSpinsSummary(totalWon) {
                let modal = document.getElementById('freeSpinsSummaryModal');
                if (!modal) {
                    modal = this.createFreeSpinsSummaryModal();
                }
                
                document.getElementById('summaryWinAmount').textContent = `${totalWon} MY`;
                
                if (totalWon > 0) {
                    document.getElementById('summaryTitle').textContent = '🎉 FREE SPINS COMPLETE!';
                    document.getElementById('summaryMessage').textContent = 'Congratulations on your free spins victory!';
                    document.getElementById('summaryEmoji').textContent = '🎊';
                } else {
                    document.getElementById('summaryTitle').textContent = '🌙 FREE SPINS COMPLETE';
                    document.getElementById('summaryMessage').textContent = 'Better luck next time, space explorer!';
                    document.getElementById('summaryEmoji').textContent = '🚀';
                }
                
                modal.classList.add('show');
                
                // Auto close after 4 seconds
                setTimeout(() => {
                    this.closeModal('freeSpinsSummaryModal');
                }, 4000);
            }

            createFreeSpinsSummaryModal() {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'freeSpinsSummaryModal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2 id="summaryTitle">🎉 FREE SPINS COMPLETE!</h2>
                        <div style="font-size: 3rem; margin: 1rem 0;" id="summaryEmoji">🎊</div>
                        <p id="summaryMessage">Congratulations on your free spins!</p>
                        <div style="font-size: 2rem; color: var(--accent); font-weight: 800; margin: 1rem 0;" id="summaryWinAmount">
                            0 MY
                        </div>
                        <div style="margin: 1.5rem 0; color: var(--gray-400); font-size: 0.9rem;">
                            Returning to normal play mode...
                        </div>
                        <div class="modal-buttons">
                            <button class="modal-btn" onclick="closeModal('freeSpinsSummaryModal')">Continue Playing</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                return modal;
            }

            checkBonusAchievements() {
                const achievements = [];

                // First bonus achievement
                if (gameState.bonusRoundsTriggered === 1 && !gameState.achievements.has('first-bonus')) {
                    achievements.push({
                        id: 'first-bonus',
                        title: '🎮 First Bonus Round',
                        description: 'You triggered your first bonus game!'
                    });
                }

                // Bonus master achievement
                if (gameState.bonusRoundsTriggered >= 5 && !gameState.achievements.has('bonus-master')) {
                    achievements.push({
                        id: 'bonus-master',
                        title: '🏆 Bonus Master',
                        description: 'You\'ve triggered 5 bonus rounds!'
                    });
                }

                // Show achievements
                achievements.forEach((achievement, index) => {
                    gameState.achievements.add(achievement.id);
                    this.safeTimeout(() => {
                        this.showAchievement(achievement.title, achievement.description);
                        this.updateAchievementsDisplay();
                    }, index * 1000);
                });
            }

            showWinEffects(winAmount) {
                // Highlight winning symbols
                this.highlightWinningSymbols();

                // Show paylines
                this.showWinningPaylines();

                // Determine win level
                const betMultiplier = winAmount / (gameState.currentBet * gameState.activeLines);
                
                if (betMultiplier >= 100) {
                    this.showBigWin(winAmount, 'MEGA WIN!', '🎰');
                    this.createConfetti();
                } else if (betMultiplier >= 50) {
                    this.showBigWin(winAmount, 'BIG WIN!', '🚀');
                } else if (betMultiplier >= 10) {
                    this.showBigWin(winAmount, 'NICE WIN!', '⭐');
                }

                // Update last win display
                document.getElementById('lastWin').textContent = `${winAmount} MY`;
            }

            highlightWinningSymbols() {
                // Clear previous highlights
                document.querySelectorAll('.symbol').forEach(symbol => {
                    symbol.classList.remove('winning');
                });

                // Highlight winning symbols
                gameState.winningLines.forEach(line => {
                    line.positions.forEach((pos, reel) => {
                        const reelElement = document.getElementById(`reel-${reel}`);
                        const symbols = reelElement.querySelectorAll('.symbol');
                        if (symbols[pos + 3]) {
                            symbols[pos + 3].classList.add('winning');
                        }
                    });
                });
            }

            showWinningPaylines() {
                const svg = document.getElementById('paylinesOverlay');
                svg.innerHTML = ''; // Clear previous paylines

                gameState.winningLines.forEach((line, index) => {
                    setTimeout(() => {
                        this.drawPayline(svg, line.line);
                    }, index * 500);
                });
            }

            drawPayline(svg, lineIndex) {
                const line = PAYLINES[lineIndex];
                const reelWidth = svg.clientWidth / 5;
                const reelHeight = svg.clientHeight;
                const symbolHeight = reelHeight / 3;

                let pathData = '';
                line.forEach((pos, reel) => {
                    const x = (reel * reelWidth) + (reelWidth / 2);
                    const y = (pos * symbolHeight) + (symbolHeight / 2);
                    
                    if (reel === 0) {
                        pathData += `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.className = 'payline active';
                svg.appendChild(path);

                // Remove payline after animation
                setTimeout(() => {
                    if (path.parentNode) {
                        path.parentNode.removeChild(path);
                    }
                }, 2000);
            }

            showBigWin(amount, title, emoji) {
                document.getElementById('bigWinTitle').textContent = title;
                document.getElementById('bigWinEmoji').textContent = emoji;
                document.getElementById('bigWinAmount').textContent = `${amount} MY`;
                document.getElementById('bigWinMessage').textContent = `You won ${amount} MoonYetis tokens!`;
                
                document.getElementById('bigWinModal').classList.add('show');
                
                // Auto close after 5 seconds
                setTimeout(() => {
                    this.closeModal('bigWinModal');
                }, 5000);
            }

            createConfetti() {
                const celebration = document.getElementById('winCelebration');
                celebration.innerHTML = '';

                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    confetti.style.backgroundColor = ['#FF6B35', '#4ECDC4', '#FFE66D'][Math.floor(Math.random() * 3)];
                    celebration.appendChild(confetti);
                }

                setTimeout(() => {
                    celebration.innerHTML = '';
                }, 3000);
            }

            addRecentWin(amount) {
                gameState.recentWins.unshift({
                    amount: amount,
                    time: new Date().toLocaleTimeString()
                });

                if (gameState.recentWins.length > 10) {
                    gameState.recentWins.pop();
                }

                this.updateRecentWinsDisplay();
            }

            updateRecentWinsDisplay() {
                const container = document.getElementById('recentWins');
                
                if (gameState.recentWins.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: var(--gray-400); padding: 2rem;">
                            <p>🎯 Start playing to see your wins!</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = gameState.recentWins.map(win => `
                    <div class="win-item">
                        <div>
                            <div class="win-amount">${win.amount} MY</div>
                            <div class="win-time">${win.time}</div>
                        </div>
                        <div style="font-size: 1.5rem;">🎉</div>
                    </div>
                `).join('');
            }

            checkAchievements(winResult) {
                const achievements = [];

                // First spin achievement
                if (gameState.totalSpins === 1 && !gameState.achievements.has('first-spin')) {
                    achievements.push({
                        id: 'first-spin',
                        title: '🎰 First Spin',
                        description: 'Welcome to MoonYetis Slots!'
                    });
                }

                // Lucky seven achievement - changed to 7 wins (not total won amount)
                if (gameState.recentWins.length >= 7 && !gameState.achievements.has('lucky-seven')) {
                    achievements.push({
                        id: 'lucky-seven',
                        title: '🍀 Lucky Seven',
                        description: 'You\'ve had 7 winning spins!'
                    });
                }

                // High roller achievement - reduced threshold
                if (gameState.currentBet >= 50 && !gameState.achievements.has('high-roller')) {
                    achievements.push({
                        id: 'high-roller',
                        title: '💎 High Roller',
                        description: 'Betting big like a true space explorer!'
                    });
                }

                // Big win achievement - win more than 20x bet
                const betMultiplier = winResult.totalWin > 0 ? winResult.totalWin / (gameState.currentBet * gameState.activeLines) : 0;
                if (betMultiplier >= 20 && !gameState.achievements.has('big-winner')) {
                    achievements.push({
                        id: 'big-winner',
                        title: '🎯 Big Winner',
                        description: 'Amazing! 20x bet multiplier!'
                    });
                }

                // Space explorer achievement
                if (gameState.totalSpins >= 50 && !gameState.achievements.has('space-explorer')) {
                    achievements.push({
                        id: 'space-explorer',
                        title: '🚀 Space Explorer',
                        description: '50 spins completed!'
                    });
                }

                // Persistent player achievement
                if (gameState.totalSpins >= 100 && !gameState.achievements.has('persistent-player')) {
                    achievements.push({
                        id: 'persistent-player',
                        title: '⭐ Persistent Player',
                        description: 'Dedication pays off - 100 spins!'
                    });
                }

                // Show achievements
                achievements.forEach((achievement, index) => {
                    gameState.achievements.add(achievement.id);
                    setTimeout(() => {
                        this.showAchievement(achievement.title, achievement.description);
                        this.updateAchievementsDisplay();
                    }, index * 1000);
                });
            }

            showAchievement(title, description) {
                document.getElementById('achievementTitle').textContent = title;
                document.getElementById('achievementDesc').textContent = description;
                
                const modal = document.getElementById('achievementModal');
                modal.classList.add('show');
                
                setTimeout(() => {
                    modal.classList.remove('show');
                }, 3000);
            }

            updateAchievementsDisplay() {
                const achievements = document.querySelectorAll('.achievement-item');
                achievements.forEach(item => {
                    const achievementId = item.dataset.achievement;
                    if (gameState.achievements.has(achievementId)) {
                        item.style.opacity = '1';
                        item.style.color = 'var(--accent)';
                    }
                });
            }

            adjustBet(direction) {
                const minBet = GAME_CONFIG.MIN_BET;
                const maxBet = Math.min(GAME_CONFIG.MAX_BET, Math.floor(gameState.balance / gameState.activeLines));
                
                if (direction > 0 && gameState.currentBet < maxBet) {
                    // Increment by 5K MY
                    const increment = 5000;
                    gameState.currentBet = Math.min(gameState.currentBet + increment, maxBet);
                } else if (direction < 0 && gameState.currentBet > minBet) {
                    // Decrement by 5K MY
                    const decrement = 5000;
                    gameState.currentBet = Math.max(gameState.currentBet - decrement, minBet);
                }
                
                this.updateUI();
            }

            adjustLines(direction) {
                const minLines = GAME_CONFIG.MIN_LINES;
                const maxLines = GAME_CONFIG.MAX_LINES;
                
                if (direction > 0 && gameState.activeLines < maxLines) {
                    gameState.activeLines++;
                } else if (direction < 0 && gameState.activeLines > minLines) {
                    gameState.activeLines--;
                }
                
                this.updateUI();
            }

            toggleAutoSpin() {
                if (gameState.isAutoSpin) {
                    gameState.isAutoSpin = false;
                    gameState.autoSpinCount = 0;
                } else {
                    gameState.isAutoSpin = true;
                    gameState.autoSpinCount = 10; // Auto spin 10 times
                    this.spin();
                }
                
                this.updateUI();
            }

            showWalletModal() {
                document.getElementById('walletModal').classList.add('show');
            }

            showInsufficientBalanceModal(required) {
                document.getElementById('requiredAmount').textContent = `${required} MY`;
                document.getElementById('availableAmount').textContent = `${gameState.balance} MY`;
                document.getElementById('balanceModal').classList.add('show');
            }

            closeModal(modalId) {
                document.getElementById(modalId).classList.remove('show');
            }

            formatMY(amount) {
                return amount.toLocaleString() + ' MY';
            }

            updateUI() {
                // Update balance
                document.getElementById('balance').textContent = this.formatMY(gameState.balance);
                
                // Update bet controls
                document.getElementById('betAmount').textContent = this.formatMY(gameState.currentBet);
                document.getElementById('activeLines').textContent = gameState.activeLines;
                
                const totalBet = gameState.currentBet * gameState.activeLines;
                document.getElementById('totalBet').textContent = this.formatMY(totalBet);
                
                // Update calculation display
                if (document.getElementById('betCalculation')) {
                    document.getElementById('betCalculation').textContent = `${this.formatMY(gameState.currentBet)} × ${gameState.activeLines} líneas`;
                }
                
                // Update stats
                document.getElementById('totalSpins').textContent = gameState.totalSpins;
                document.getElementById('totalWagered').textContent = this.formatMY(gameState.totalWagered);
                document.getElementById('totalWon').textContent = this.formatMY(gameState.totalWon);
                document.getElementById('biggestWin').textContent = this.formatMY(gameState.biggestWin);
                
                // Update button states
                const spinBtn = document.getElementById('spinBtn');
                const autoSpinBtn = document.getElementById('autoSpinBtn');
                const slotMachine = document.querySelector('.slot-machine');
                
                // Handle bonus mode styling
                if (gameState.isBonusMode) {
                    // Hide main slot machine during bonus
                    slotMachine.style.display = 'none';
                    
                    // Add bonus mode indicator if not exists
                    if (!document.querySelector('.bonus-mode-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'bonus-mode-indicator';
                        indicator.textContent = '🎮 BONUS ROUND ACTIVE';
                        document.body.appendChild(indicator);
                    }
                } else {
                    // Show main slot machine
                    slotMachine.style.display = 'block';
                    
                    // Remove bonus mode indicator
                    const indicator = document.querySelector('.bonus-mode-indicator');
                    if (indicator) indicator.remove();
                }
                
                // Handle free spins mode styling
                if (gameState.isFreeSpinsMode) {
                    slotMachine.classList.add('free-spins-mode');
                    
                    // Add or update free spins counter
                    let counter = document.querySelector('.free-spins-counter');
                    if (!counter) {
                        counter = document.createElement('div');
                        counter.className = 'free-spins-counter';
                        slotMachine.appendChild(counter);
                    }
                    counter.textContent = `🌙 ${gameState.freeSpinsRemaining} FREE SPINS`;
                } else {
                    slotMachine.classList.remove('free-spins-mode');
                    const counter = document.querySelector('.free-spins-counter');
                    if (counter) counter.remove();
                }
                
                if (gameState.isSpinning) {
                    spinBtn.classList.add('spinning');
                    spinBtn.disabled = true;
                    document.getElementById('spinBtnText').innerHTML = '<div class="loading"></div>';
                } else {
                    spinBtn.classList.remove('spinning');
                    spinBtn.disabled = gameState.isBonusMode; // Disable spin during bonus
                    
                    if (gameState.isFreeSpinsMode) {
                        document.getElementById('spinBtnText').textContent = '✨ FREE SPIN';
                    } else if (gameState.turboMode) {
                        document.getElementById('spinBtnText').textContent = '⚡ TURBO SPIN';
                    } else {
                        document.getElementById('spinBtnText').textContent = '🎯 SPIN';
                    }
                }
                
                if (gameState.isAutoSpin) {
                    autoSpinBtn.classList.add('active');
                    document.getElementById('autoSpinText').textContent = `🔄 AUTO (${gameState.autoSpinCount})`;
                } else {
                    autoSpinBtn.classList.remove('active');
                    document.getElementById('autoSpinText').textContent = '🔄 AUTO';
                }
                
                // Disable auto spin during free spins or bonus mode
                autoSpinBtn.disabled = gameState.isFreeSpinsMode || gameState.isSpinning || gameState.isBonusMode;
                
                // Update connection status
                const statusEl = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                const walletBtn = document.getElementById('connectWallet');
                const walletBtnText = document.getElementById('walletBtnText');
                
                if (gameState.connectedWallet) {
                    statusEl.className = 'status-indicator connected';
                    if (gameState.isBonusMode) {
                        statusText.textContent = '🎮 Bonus Round';
                    } else if (gameState.isFreeSpinsMode) {
                        statusText.textContent = '🌙 Free Spins Mode';
                    } else {
                        statusText.textContent = gameState.demoMode ? 'Demo Mode' : 'Connected';
                    }
                    walletBtnText.textContent = 'Disconnect';
                } else {
                    statusEl.className = 'status-indicator disconnected';
                    statusText.textContent = 'Not Connected';
                    walletBtnText.textContent = 'Connect Wallet';
                }
                
                // Update jackpot (simulate progressive)
                const jackpot = 125847 + (gameState.totalWagered * 0.01);
                document.getElementById('jackpotAmount').textContent = `${Math.floor(jackpot).toLocaleString()} MY`;
                
                // Disable controls if not connected, spinning, in free spins mode, or bonus mode
                const controlBtns = document.querySelectorAll('.control-btn');
                controlBtns.forEach(btn => {
                    btn.disabled = !gameState.connectedWallet || gameState.isSpinning || 
                                  gameState.isFreeSpinsMode || gameState.isBonusMode;
                });
                
                // Update bet display for free spins
                if (gameState.isFreeSpinsMode) {
                    document.getElementById('totalBet').textContent = 'FREE';
                    document.getElementById('totalBet').style.color = 'var(--secondary)';
                } else if (gameState.isBonusMode) {
                    document.getElementById('totalBet').textContent = 'BONUS';
                    document.getElementById('totalBet').style.color = 'var(--accent)';
                } else {
                    document.getElementById('totalBet').style.color = 'var(--accent)';
                }
            }

            startBackgroundEffects() {
                // Create floating particles
                const particles = document.getElementById('particles');
                
                setInterval(() => {
                    if (particles.children.length < 20) {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.left = Math.random() * 100 + '%';
                        particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                        particles.appendChild(particle);
                        
                        setTimeout(() => {
                            if (particle.parentNode) {
                                particle.parentNode.removeChild(particle);
                            }
                        }, 20000);
                    }
                }, 2000);
            }

            // Load and display leaderboard
            async loadLeaderboard(sortBy = 'total_wagered') {
                const leaderboardList = document.getElementById('leaderboardList');
                if (!leaderboardList) return;

                // Show loading state
                leaderboardList.innerHTML = `
                    <div class="leaderboard-empty">
                        🔄 Loading rankings...
                    </div>
                `;

                try {
                    const result = await walletManager.getLeaderboard(sortBy, 20);
                    
                    if (result.success && result.data && result.data.leaderboard) {
                        this.renderLeaderboard(result.data.leaderboard, sortBy);
                    } else {
                        leaderboardList.innerHTML = `
                            <div class="leaderboard-empty">
                                📊 No player data available yet.<br>
                                Be the first to play and appear on the leaderboard!
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error loading leaderboard:', error);
                    leaderboardList.innerHTML = `
                        <div class="leaderboard-empty">
                            ❌ Failed to load leaderboard.<br>
                            Please try again later.
                        </div>
                    `;
                }
            }

            // Render leaderboard data
            renderLeaderboard(players, sortBy) {
                const leaderboardList = document.getElementById('leaderboardList');
                if (!leaderboardList || !players || players.length === 0) {
                    leaderboardList.innerHTML = `
                        <div class="leaderboard-empty">
                            🏆 No players yet. Be the first!
                        </div>
                    `;
                    return;
                }

                leaderboardList.innerHTML = `
                    <div class="leaderboard-list">
                        ${players.map((player, index) => {
                            const rank = player.rank || index + 1;
                            const isTop3 = rank <= 3;
                            const isCurrentPlayer = walletManager.connectedWallet === player.wallet_address;
                            
                            return `
                                <div class="leaderboard-item ${isCurrentPlayer ? 'current-player' : ''}">
                                    <div class="leaderboard-rank ${isTop3 ? 'top-3' : ''}">${rank}</div>
                                    <div class="leaderboard-player">
                                        <div class="leaderboard-wallet">${this.formatWalletAddress(player.wallet_address)}</div>
                                        <div class="leaderboard-stats">${this.getPlayerStatsText(player, sortBy)}</div>
                                    </div>
                                    <div class="leaderboard-value">
                                        <div class="leaderboard-primary">${this.formatLeaderboardValue(player, sortBy)}</div>
                                        <div class="leaderboard-secondary">${this.getSecondaryValue(player, sortBy)}</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Format wallet address for display
            formatWalletAddress(address) {
                if (!address) return 'Unknown';
                if (address.length <= 16) return address;
                return `${address.substring(0, 8)}...${address.substring(address.length - 6)}`;
            }

            // Get primary value based on sort type
            formatLeaderboardValue(player, sortBy) {
                switch (sortBy) {
                    case 'biggest_win':
                        return `${parseFloat(player.biggest_win || 0).toFixed(2)} MOONY`;
                    case 'profit_loss':
                        const profit = parseFloat(player.profit_loss || 0);
                        return `${profit >= 0 ? '+' : ''}${profit.toFixed(2)} MOONY`;
                    case 'total_spins':
                        return `${parseInt(player.total_spins || 0)} spins`;
                    case 'total_won':
                        return `${parseFloat(player.total_won || 0).toFixed(2)} MOONY`;
                    default:
                        return `${parseFloat(player.total_wagered || 0).toFixed(2)} MOONY`;
                }
            }

            // Get secondary display value
            getSecondaryValue(player, sortBy) {
                switch (sortBy) {
                    case 'biggest_win':
                        return `${parseInt(player.total_spins || 0)} spins`;
                    case 'profit_loss':
                        return `${parseInt(player.total_spins || 0)} spins`;
                    case 'total_spins':
                        return `${parseFloat(player.total_wagered || 0).toFixed(2)} wagered`;
                    case 'total_won':
                        return `${parseInt(player.total_spins || 0)} spins`;
                    default:
                        return `${parseInt(player.total_spins || 0)} spins`;
                }
            }

            // Get player stats text
            getPlayerStatsText(player, sortBy) {
                const winRate = player.total_spins > 0 ? ((player.total_won / player.total_wagered) * 100) : 0;
                return `Win rate: ${winRate.toFixed(1)}%`;
            }

            // Update leaderboard after spin (called from spin result processing)
            async updatePlayerLeaderboardStats(betAmount, winAmount, isWin) {
                if (walletManager && walletManager.connectedWallet) {
                    try {
                        await walletManager.updateLeaderboardStats(betAmount, winAmount, isWin);
                        // Refresh leaderboard if visible
                        const leaderboardSort = document.getElementById('leaderboardSort');
                        if (leaderboardSort) {
                            this.loadLeaderboard(leaderboardSort.value);
                        }
                    } catch (error) {
                        console.error('Error updating player leaderboard stats:', error);
                    }
                }
            }
        }

        // === WALLET CONNECTION FUNCTIONS === (DISABLED - Using modular v3.0 system)
        /*async function connectWallet(walletType) {
            const statusEl = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            const walletBtnText = document.getElementById('walletBtnText');
            
            statusEl.className = 'status-indicator processing';
            statusText.textContent = 'Connecting...';
            walletBtnText.innerHTML = '<div class="loading"></div>';
            
            // Add timeout to prevent hanging forever
            const connectionTimeout = setTimeout(() => {
                if (statusText.textContent === 'Connecting...') {
                    statusEl.className = 'status-indicator disconnected';
                    statusText.textContent = 'Connection Timeout';
                    walletBtnText.textContent = 'Try Again';
                    console.warn('Wallet connection timed out after 10 seconds');
                }
            }, 10000); // 10 second timeout
            
            try {
                const result = await walletManager.connectWallet(walletType);
                clearTimeout(connectionTimeout); // Clear timeout on successful response
                
                if (result.success) {
                    slotMachine.closeModal('walletModal');
                    slotMachine.updateUI();
                    
                    if (walletType === 'demo') {
                        slotMachine.showAchievement('🎮 Demo Mode', 'Welcome to MoonYetis Slots demo!');
                    } else {
                        slotMachine.showAchievement('🔗 Wallet Connected', `${walletType} wallet connected successfully!`);
                    }
                } else {
                    statusEl.className = 'status-indicator disconnected';
                    
                    // Handle specific error types
                    if (result.error === 'Connection cancelled by user') {
                        statusText.textContent = 'Connection Cancelled';
                        walletBtnText.textContent = 'Connect Wallet';
                        // Auto-reset after user cancellation
                        setTimeout(() => {
                            if (statusText.textContent === 'Connection Cancelled') {
                                statusText.textContent = 'Not Connected';
                            }
                        }, 3000);
                    } else if (result.error?.includes('not installed')) {
                        statusText.textContent = 'Wallet Not Found';
                        walletBtnText.textContent = 'Install Wallet';
                        // Auto-reset after 5 seconds
                        setTimeout(() => {
                            if (statusText.textContent === 'Wallet Not Found') {
                                statusText.textContent = 'Not Connected';
                                walletBtnText.textContent = 'Connect Wallet';
                            }
                        }, 5000);
                    } else {
                        statusText.textContent = 'Connection Failed';
                        walletBtnText.textContent = 'Try Again';
                        // Auto-reset after 5 seconds
                        setTimeout(() => {
                            if (statusText.textContent === 'Connection Failed') {
                                statusText.textContent = 'Not Connected';
                                walletBtnText.textContent = 'Connect Wallet';
                            }
                        }, 5000);
                    }
                    
                    console.warn('Wallet connection failed:', result.error);
                }
            } catch (error) {
                clearTimeout(connectionTimeout);
                // Handle unexpected errors
                statusEl.className = 'status-indicator disconnected';
                statusText.textContent = 'Connection Error';
                walletBtnText.textContent = 'Try Again';
                console.error('Unexpected wallet error:', error);
                
                // Auto-reset after 5 seconds
                setTimeout(() => {
                    if (statusText.textContent === 'Connection Error') {
                        statusText.textContent = 'Not Connected';
                        walletBtnText.textContent = 'Connect Wallet';
                    }
                }, 5000);
            }
        }*/

        function reducebet() {
            const maxAffordableBet = Math.floor(gameState.balance / gameState.activeLines);
            gameState.currentBet = Math.max(1, maxAffordableBet);
            slotMachine.updateUI();
            slotMachine.closeModal('balanceModal');
        }

        function shareBigWin() {
            const winAmount = document.getElementById('bigWinAmount').textContent;
            const text = `🎰 HUGE WIN! I just won ${winAmount} playing MoonYetis Slots! 🚀 The future of crypto gaming is here! #MoonYetis #CryptoSlots #FractalBitcoin`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'MoonYetis Slots - Big Win!',
                    text: text,
                    url: window.location.href
                });
            } else {
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
                window.open(twitterUrl, '_blank');
            }
        }

        // === EVENT HANDLERS ===
        // Wallet connection handled in wallet-integration.js

        // Close modals when clicking outside
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('show');
                }
            });
        });

        // Close modal functions
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // === INITIALIZATION ===
        let slotMachine;

        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎰 Initializing MoonYetis Slots...');
            
            // IMMEDIATE DEBUG - Test button access before SlotMachine
            console.log('🚨 IMMEDIATE BUTTON TEST:');
            console.log('betUp element:', document.getElementById('betUp'));
            console.log('betDown element:', document.getElementById('betDown'));
            console.log('linesUp element:', document.getElementById('linesUp'));
            console.log('linesDown element:', document.getElementById('linesDown'));
            console.log('autoSpinBtn element:', document.getElementById('autoSpinBtn'));
            
            // IMMEDIATE AUTO BUTTON TEST
            const autoBtn = document.getElementById('autoSpinBtn');
            if (autoBtn) {
                console.log('🤖 AUTO BUTTON DETAILS:', {
                    disabled: autoBtn.disabled,
                    classList: autoBtn.classList.toString(),
                    textContent: autoBtn.textContent,
                    onclick: autoBtn.onclick
                });
            }
            
            try {
                console.log('🏗️ Creating SlotMachine instance...');
                slotMachine = new SlotMachine();
                window.slotMachine = slotMachine; // Make it globally accessible
                console.log('✅ SlotMachine created and assigned to window.slotMachine');
                console.log('toggleAutoSpin method exists:', typeof slotMachine.toggleAutoSpin);
            } catch (error) {
                console.error('❌ SlotMachine initialization failed:', error);
                console.error('Error details:', error.stack);
                // Continue anyway to try fixing buttons
            }
            
            // Force global AUTO function
            window.toggleAutoSpinGlobal = function() {
                console.log('🤖 GLOBAL AUTO TOGGLE CALLED');
                console.log('Current auto state:', gameState.isAutoSpin);
                
                if (gameState.isAutoSpin) {
                    gameState.isAutoSpin = false;
                    gameState.autoSpinCount = 0;
                    console.log('✅ Auto spin STOPPED');
                    const autoText = document.getElementById('autoSpinText');
                    if (autoText) autoText.textContent = '🔄 AUTO';
                } else {
                    gameState.isAutoSpin = true;
                    gameState.autoSpinCount = 10;
                    console.log('✅ Auto spin STARTED - 10 spins');
                    const autoText = document.getElementById('autoSpinText');
                    if (autoText) autoText.textContent = '🔄 AUTO (10)';
                    
                    // Try to trigger first spin
                    if (slotMachine && slotMachine.spin && !gameState.isSpinning) {
                        console.log('🎰 Triggering first auto spin...');
                        setTimeout(() => {
                            try {
                                slotMachine.spin();
                            } catch (error) {
                                console.error('❌ Auto spin failed:', error);
                            }
                        }, 100);
                    } else {
                        console.log('⚠️ Cannot trigger auto spin - slotMachine not ready or already spinning');
                    }
                }
                
                if (slotMachine && slotMachine.updateUI) {
                    slotMachine.updateUI();
                }
            };

            // Force global bet/lines control functions
            window.adjustBetGlobal = function(direction) {
                const minBet = GAME_CONFIG.MIN_BET;
                const maxBet = Math.min(GAME_CONFIG.MAX_BET, Math.floor(gameState.balance / gameState.activeLines));
                
                if (direction > 0 && gameState.currentBet < maxBet) {
                    gameState.currentBet = Math.min(gameState.currentBet + 5000, maxBet);
                } else if (direction < 0 && gameState.currentBet > minBet) {
                    gameState.currentBet = Math.max(gameState.currentBet - 5000, minBet);
                }
                
                if (slotMachine && slotMachine.updateUI) {
                    slotMachine.updateUI();
                }
            };
            
            window.adjustLinesGlobal = function(direction) {
                const minLines = GAME_CONFIG.MIN_LINES;
                const maxLines = GAME_CONFIG.MAX_LINES;
                
                if (direction > 0 && gameState.activeLines < maxLines) {
                    gameState.activeLines = Math.min(gameState.activeLines + 5, maxLines);
                } else if (direction < 0 && gameState.activeLines > minLines) {
                    gameState.activeLines = Math.max(gameState.activeLines - 5, minLines);
                }
                
                if (slotMachine && slotMachine.updateUI) {
                    slotMachine.updateUI();
                }
            };
            
            // Force bind global event listeners with detailed debugging
            setTimeout(() => {
                console.log('🔧 Binding global betting controls...');
                
                const betUp = document.getElementById('betUp');
                const betDown = document.getElementById('betDown');
                const linesUp = document.getElementById('linesUp');
                const linesDown = document.getElementById('linesDown');
                
                const autoSpinBtn = document.getElementById('autoSpinBtn');
                
                console.log('🔍 Button elements found:', {
                    betUp: betUp ? 'FOUND' : 'NOT FOUND',
                    betDown: betDown ? 'FOUND' : 'NOT FOUND', 
                    linesUp: linesUp ? 'FOUND' : 'NOT FOUND',
                    linesDown: linesDown ? 'FOUND' : 'NOT FOUND',
                    autoSpinBtn: autoSpinBtn ? 'FOUND' : 'NOT FOUND'
                });
                
                console.log('🎮 Current gameState:', {
                    balance: gameState.balance,
                    currentBet: gameState.currentBet,
                    activeLines: gameState.activeLines,
                    minBet: GAME_CONFIG.MIN_BET,
                    maxBet: GAME_CONFIG.MAX_BET
                });
                
                if (betUp) {
                    // FORCE ENABLE THE BUTTON
                    betUp.disabled = false;
                    betUp.removeAttribute('disabled');
                    
                    // Remove any existing handlers first
                    betUp.onclick = null;
                    betUp.removeAttribute('onclick');
                    
                    betUp.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 BET UP CLICKED - Current bet:', gameState.currentBet);
                        if (window.audioManager) window.audioManager.playSound('click');
                        window.adjustBetGlobal(1);
                        return false;
                    };
                    console.log('✅ betUp handler bound AND ENABLED');
                }
                
                if (betDown) {
                    // FORCE ENABLE THE BUTTON
                    betDown.disabled = false;
                    betDown.removeAttribute('disabled');
                    
                    betDown.onclick = null;
                    betDown.removeAttribute('onclick');
                    
                    betDown.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 BET DOWN CLICKED - Current bet:', gameState.currentBet);
                        if (window.audioManager) window.audioManager.playSound('click');
                        window.adjustBetGlobal(-1);
                        return false;
                    };
                    console.log('✅ betDown handler bound AND ENABLED');
                }
                
                if (linesUp) {
                    // FORCE ENABLE THE BUTTON
                    linesUp.disabled = false;
                    linesUp.removeAttribute('disabled');
                    
                    linesUp.onclick = null;
                    linesUp.removeAttribute('onclick');
                    
                    linesUp.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 LINES UP CLICKED - Current lines:', gameState.activeLines);
                        if (window.audioManager) window.audioManager.playSound('click');
                        window.adjustLinesGlobal(1);
                        return false;
                    };
                    console.log('✅ linesUp handler bound AND ENABLED');
                }
                
                if (linesDown) {
                    // FORCE ENABLE THE BUTTON
                    linesDown.disabled = false;
                    linesDown.removeAttribute('disabled');
                    
                    linesDown.onclick = null;
                    linesDown.removeAttribute('onclick');
                    
                    linesDown.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 LINES DOWN CLICKED - Current lines:', gameState.activeLines);
                        if (window.audioManager) window.audioManager.playSound('click');
                        window.adjustLinesGlobal(-1);
                        return false;
                    };
                    console.log('✅ linesDown handler bound AND ENABLED');
                }
                
                if (autoSpinBtn) {
                    // FORCE ENABLE THE AUTO BUTTON
                    autoSpinBtn.disabled = false;
                    autoSpinBtn.removeAttribute('disabled');
                    
                    autoSpinBtn.onclick = null;
                    autoSpinBtn.removeAttribute('onclick');
                    
                    // Skip AUTO button - handled by main event listener
                    console.log('✅ autoSpinBtn handler bound AND ENABLED');
                }
                
                console.log('✅ Global betting controls bound with enhanced debugging');
            }, 1000);
            
            // EMERGENCY BACKUP - Force attach after 3 seconds no matter what
            setTimeout(() => {
                console.log('🚨 EMERGENCY BACKUP - Force attaching button handlers...');
                
                // Try multiple ways to find and attach
                const selectors = ['#betUp', '#betDown', '#linesUp', '#linesDown', '#autoSpinBtn'];
                selectors.forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        console.log(`Found ${selector}:`, element);
                        
                        // FORCE ENABLE ALL BUTTONS
                        element.disabled = false;
                        element.removeAttribute('disabled');
                        console.log(`✅ ${selector} FORCE ENABLED`);
                        
                        if (selector === '#betUp') {
                            element.addEventListener('click', function(e) {
                                console.log('🔥 EMERGENCY BET UP CLICKED!');
                                e.preventDefault();
                                gameState.currentBet = Math.min(gameState.currentBet + 5000, GAME_CONFIG.MAX_BET);
                                console.log('New bet:', gameState.currentBet);
                                if (slotMachine && slotMachine.updateUI) slotMachine.updateUI();
                            }, true);
                        }
                        
                        if (selector === '#betDown') {
                            element.addEventListener('click', function(e) {
                                console.log('🔥 EMERGENCY BET DOWN CLICKED!');
                                e.preventDefault();
                                gameState.currentBet = Math.max(gameState.currentBet - 5000, GAME_CONFIG.MIN_BET);
                                console.log('New bet:', gameState.currentBet);
                                if (slotMachine && slotMachine.updateUI) slotMachine.updateUI();
                            }, true);
                        }
                        
                        if (selector === '#linesUp') {
                            element.addEventListener('click', function(e) {
                                console.log('🔥 EMERGENCY LINES UP CLICKED!');
                                e.preventDefault();
                                gameState.activeLines = Math.min(gameState.activeLines + 5, GAME_CONFIG.MAX_LINES);
                                console.log('New lines:', gameState.activeLines);
                                if (slotMachine && slotMachine.updateUI) slotMachine.updateUI();
                            }, true);
                        }
                        
                        if (selector === '#linesDown') {
                            element.addEventListener('click', function(e) {
                                console.log('🔥 EMERGENCY LINES DOWN CLICKED!');
                                e.preventDefault();
                                gameState.activeLines = Math.max(gameState.activeLines - 5, GAME_CONFIG.MIN_LINES);
                                console.log('New lines:', gameState.activeLines);
                                if (slotMachine && slotMachine.updateUI) slotMachine.updateUI();
                            }, true);
                        }
                        
                        // Skip AUTO button - handled by main event listener
                    } else {
                        console.error(`❌ Could not find element: ${selector}`);
                    }
                });
                
                console.log('🚨 EMERGENCY BACKUP COMPLETE');
                
                // DIAGNOSTIC TEST - Check what's actually happening
                setTimeout(() => {
                    console.log('🔍 DIAGNOSTIC TEST - AUTO BUTTON STATUS:');
                    const autoBtn = document.getElementById('autoSpinBtn');
                    if (autoBtn) {
                        console.log('Button found:', autoBtn);
                        console.log('Disabled:', autoBtn.disabled);
                        console.log('Classes:', autoBtn.className);
                        console.log('Text content:', autoBtn.textContent);
                        console.log('Has onclick:', !!autoBtn.onclick);
                        console.log('Event listeners attached:', autoBtn.getEventListeners ? autoBtn.getEventListeners() : 'Cannot check');
                        
                        // Manual click test
                        console.log('🧪 MANUAL CLICK TEST...');
                        try {
                            autoBtn.click();
                            console.log('✅ Manual click successful');
                        } catch (error) {
                            console.error('❌ Manual click failed:', error);
                        }
                    } else {
                        console.error('❌ AUTO BUTTON NOT FOUND IN DIAGNOSTIC');
                    }
                }, 2000);
                
            }, 3000);
            
            // Temporary simple AUTO function
            window.simpleAutoSpin = function() {
                console.log('🔄 Simple AUTO SPIN triggered');
                
                if (gameState.isAutoSpin) {
                    // Stop auto spinning
                    gameState.isAutoSpin = false;
                    gameState.autoSpinCount = 0;
                    
                    const autoBtn = document.getElementById('autoSpinBtn');
                    const spanText = autoBtn?.querySelector('#autoSpinText');
                    if (spanText) {
                        spanText.textContent = '🔄 AUTO';
                    }
                    if (autoBtn) {
                        autoBtn.classList.remove('active');
                    }
                    console.log('🛑 AUTO stopped');
                } else {
                    // Start auto spinning
                    gameState.isAutoSpin = true;
                    gameState.autoSpinCount = 10;
                    
                    const autoBtn = document.getElementById('autoSpinBtn');
                    const spanText = autoBtn?.querySelector('#autoSpinText');
                    if (spanText) {
                        spanText.textContent = '🔄 AUTO (10)';
                    }
                    if (autoBtn) {
                        autoBtn.classList.add('active');
                    }
                    
                    console.log('🚀 AUTO started - 10 spins');
                    
                    // Start first spin
                    setTimeout(() => {
                        const spinBtn = document.getElementById('spinBtn');
                        if (spinBtn) {
                            spinBtn.click();
                        }
                    }, 500);
                }
            };
            
            // Auto-spin continuation function
            window.autoSpinContinuation = function() {
                console.log('🔄 Auto continuation called - checking state...');
                console.log('Auto state:', {
                    isAutoSpin: gameState.isAutoSpin,
                    autoSpinCount: gameState.autoSpinCount,
                    isSpinning: gameState.isSpinning
                });
                
                if (gameState.isAutoSpin && gameState.autoSpinCount > 0 && !gameState.isSpinning) {
                    gameState.autoSpinCount--;
                    
                    // Update button text
                    const autoBtn = document.getElementById('autoSpinBtn');
                    const spanText = autoBtn?.querySelector('#autoSpinText');
                    if (spanText) {
                        spanText.textContent = `🔄 AUTO (${gameState.autoSpinCount})`;
                    }
                    
                    console.log(`🔄 Auto spin ${10 - gameState.autoSpinCount}/10 - ${gameState.autoSpinCount} remaining`);
                    
                    if (gameState.autoSpinCount > 0) {
                        // Continue auto spinning
                        setTimeout(() => {
                            if (gameState.isAutoSpin && !gameState.isSpinning) {
                                console.log('🎰 Triggering next auto spin...');
                                const spinBtn = document.getElementById('spinBtn');
                                if (spinBtn) {
                                    spinBtn.click();
                                }
                            }
                        }, 1500);
                    } else {
                        // Auto spin sequence complete
                        gameState.isAutoSpin = false;
                        const autoBtn = document.getElementById('autoSpinBtn');
                        const spanText = autoBtn?.querySelector('#autoSpinText');
                        if (spanText) {
                            spanText.textContent = '🔄 AUTO';
                        }
                        if (autoBtn) {
                            autoBtn.classList.remove('active');
                        }
                        console.log('🏁 Auto spin sequence completed!');
                    }
                }
            };
            
            // Debug function for AUTO button
            window.debugAutoButton = function() {
                console.log('🔍 DEBUG AUTO BUTTON:');
                
                const autoBtn = document.getElementById('autoSpinBtn');
                console.log('Button exists:', !!autoBtn);
                
                if (autoBtn) {
                    console.log('Button details:', {
                        disabled: autoBtn.disabled,
                        classes: autoBtn.className,
                        text: autoBtn.textContent.trim(),
                        style: autoBtn.style.cssText,
                        onclick: autoBtn.onclick,
                        listeners: 'Cannot check event listeners directly'
                    });
                    
                    // Test if button can be clicked
                    console.log('🧪 Testing manual click...');
                    autoBtn.click();
                }
            };
            
            // Manual click test
            window.testAutoClick = function() {
                console.log('🎯 MANUAL CLICK TEST');
                const autoBtn = document.getElementById('autoSpinBtn');
                if (autoBtn) {
                    // Try simpleAutoSpin directly
                    if (typeof window.simpleAutoSpin === 'function') {
                        console.log('🔄 Calling simpleAutoSpin directly...');
                        window.simpleAutoSpin();
                    } else {
                        console.error('❌ simpleAutoSpin not available');
                    }
                } else {
                    console.error('❌ AUTO button not found');
                }
            };
            
            // Debug function for AUTO button
            window.debugAutoButton_OLD = function() {
                console.log('🔍 DEBUG AUTO BUTTON:');
                
                const autoBtn = document.getElementById('autoSpinBtn');
                console.log('Button exists:', !!autoBtn);
                if (autoBtn) {
                    console.log('Button disabled:', autoBtn.disabled);
                    console.log('Button classes:', autoBtn.className);
                    console.log('Button text:', autoBtn.textContent);
                }
                
                console.log('slotMachine exists:', !!window.slotMachine);
                if (window.slotMachine) {
                    console.log('toggleAutoSpin function exists:', typeof window.slotMachine.toggleAutoSpin);
                }
                
                console.log('gameState:', {
                    isAutoSpin: gameState?.isAutoSpin,
                    autoSpinCount: gameState?.autoSpinCount,
                    isSpinning: gameState?.isSpinning,
                    connectedWallet: gameState?.connectedWallet
                });
                
                // Try to call toggleAutoSpin directly
                if (window.slotMachine && typeof window.slotMachine.toggleAutoSpin === 'function') {
                    console.log('🧪 Testing toggleAutoSpin directly...');
                    window.slotMachine.toggleAutoSpin();
                } else {
                    console.error('❌ Cannot call toggleAutoSpin');
                }
            };
            
            // Initialize leaderboard
            setTimeout(() => {
                if (slotMachine) {
                    slotMachine.loadLeaderboard('total_wagered');
                }
            }, 2000);
            
            // Initialize audio context on first user interaction
            document.addEventListener('click', function initAudio() {
                if (window.audioManager && window.audioManager.audioContext && window.audioManager.audioContext.state === 'suspended') {
                    window.audioManager.audioContext.resume();
                }
                document.removeEventListener('click', initAudio);
            }, { once: true });
            
            // Show welcome message with sound
            setTimeout(() => {
                slotMachine.showAchievement('🌙 Welcome to MoonYetis Slots!', 'Connect your wallet to start playing with real tokens');
                if (window.audioManager) window.audioManager.playSound('celebration');
            }, 1000);
            
            // Add keyboard shortcuts info
            console.log('⌨️ Keyboard shortcuts: SPACE = Spin, T = Toggle Turbo, M = Toggle Audio');
            
            console.log('✅ MoonYetis Slots initialized successfully');
            
            // Force replace any emoji symbols with CSS classes - IMMEDIATE
            console.log('🔧 Forcing symbol replacement...');
            const emojiToClass = {
                '🏔️': 'symbol-yeti',
                '🚀': 'symbol-rocket', 
                '🌙': 'symbol-moon',
                '🪙': 'symbol-coin',
                '⭐': 'symbol-star',
                '🪐': 'symbol-planet',
                '👽': 'symbol-alien',
                '🛸': 'symbol-ufo'
            };
            
            // Immediate replacement
            setInterval(() => {
                document.querySelectorAll('.symbol, .paytable-symbol').forEach(el => {
                    const text = el.textContent.trim();
                    if (emojiToClass[text]) {
                        el.textContent = '';
                        el.className = el.className.replace(/symbol-\w+/g, '');
                        el.classList.add(emojiToClass[text]);
                        console.log(`Replaced ${text} with ${emojiToClass[text]}`);
                    }
                });
            }, 500); // Check every 500ms
            
            console.log('✅ Symbol replacement monitor active');
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', function() {
            if (slotMachine) {
                slotMachine.destroy();
            }
            if (audioManager) {
                if (audioManager) audioManager.stopBackgroundMusic();
            }
        });

        // Cleanup when page becomes hidden (mobile background)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                if (slotMachine) {
                    slotMachine.performCleanup();
                    // Pause auto-spin when page is hidden
                    if (gameState.isAutoSpin) {
                        slotMachine.toggleAutoSpin();
                    }
                }
                // Pause background music when hidden
                if (audioManager && gameState.backgroundMusicPlaying) {
                    if (audioManager) audioManager.stopBackgroundMusic();
                }
            } else {
                // Resume background music if it was playing
                if (audioManager && gameState.audioEnabled && document.getElementById('musicToggle').classList.contains('active')) {
                    if (audioManager) audioManager.startBackgroundMusic();
                }
            }
        });

        // === PERFORMANCE IMPROVEMENTS NOTES ===
        /*
        🚀 PERFORMANCE & MEMORY OPTIMIZATION IMPLEMENTED:

        ✅ MEMORY LEAK FIXES:
        - Safe timeout/interval wrappers that track and clean up
        - Automatic cleanup every 30 seconds
        - DOM element lifecycle management
        - Particle count limits (max 15 instead of 20)
        - Confetti count reduced (30 instead of 50)
        - Automatic removal of old overlays and effects

        ✅ CONCURRENCY PROTECTION:
        - Spin function guards against multiple simultaneous calls
        - Free spins and auto-spin conflict prevention
        - State validation before executing actions
        - Error handling with try-catch blocks

        ✅ RESOURCE MANAGEMENT:
        - Background particle creation frequency reduced
        - Payline animation delays optimized
        - Win effects auto-clear after 3 seconds
        - Page visibility detection for cleanup

        ✅ CLEANUP SYSTEMS:
        - destroy() method for complete cleanup
        - performCleanup() for periodic maintenance
        - beforeunload and visibilitychange event handlers
        - Clear all timers functionality

        🎯 RESULT:
        - No more hanging/freezing after multiple spins
        - Better performance on mobile devices  
        - Reduced memory usage over time
        - Smoother animations and transitions
        - Stable free spins and auto-spin modes

        The game now maintains stable performance even after
        hundreds of spins without requiring page refresh.
        */

        // === CONFIGURATION NOTES ===
        /*
        🎰 MOONYETIS SLOTS - COMPLETE CASINO EXPERIENCE WITH BONUS ROUNDS

        ✅ REALISTIC FEATURES IMPLEMENTED:
        - RTP (Return to Player): 96% - Industry standard
        - House Edge: 4% - Ensures long-term profitability
        - Weighted Symbol System: Rare symbols appear less frequently
        - Near-Miss Logic: Creates excitement without false wins
        - Volatility Control: Medium volatility for balanced gameplay
        - Realistic Paytable: Conservative payouts that make mathematical sense
        - Functional Free Spins: 3+ moons trigger 10-20 free spins with multipliers

        🚀 PERFORMANCE IMPROVEMENTS:
        - Memory leak prevention with automatic cleanup
        - Safe timeout/interval management
        - DOM element lifecycle tracking
        - Particle and effect count limits
        - Concurrency protection for spins
        - Mobile optimization with visibility detection

        🎵 AUDIO SYSTEM FEATURES:
        - Programmatic sound generation using Web Audio API
        - Themed space sounds: spin, win, big win, free spins, celebration
        - Background ambient music with harmonic tones
        - Individual volume controls for SFX and music
        - Audio toggle with visual feedback
        - Sound effects for all user interactions
        - Automatic audio context handling for mobile

        ⚡ TURBO MODE FEATURES:
        - 3x faster reel animations (600-1200ms vs 2000-4000ms)
        - Reduced effect delays (500ms vs 1500ms)
        - Faster auto-spin intervals (700ms vs 2000ms)
        - Visual indicator and styling changes
        - Keyboard shortcut support (T key)
        - Seamless integration with all game modes

        🎮 BONUS ROUNDS SYSTEM:
        ===========================
        
        🚀 MOON MISSION BONUS:
        - Trigger: 3 consecutive rockets (🚀) on any payline
        - Chance: 0.8% per spin
        - Gameplay: Select 3 planets from 6 to reveal rewards
        - Rewards: Coins (5-25x), Multipliers (2-5x), Jackpots (20-50x), Bonus (10-30x)
        - Minimum Win: 50x bet guaranteed
        - Interactive: Click planets to reveal hidden treasures
        - Visual: Animated planets with different surface types and glowing effects

        🏔️ YETI HUNT BONUS:
        - Trigger: 3 wild yetis (🏔️) anywhere on reels
        - Chance: 0.5% per spin
        - Gameplay: Catch yetis by clicking them before they disappear
        - Duration: 15 seconds time limit
        - Target: Catch 5 yetis maximum
        - Rewards: +2x bet per yeti + 0.5x multiplier increase
        - Minimum Win: 75x bet guaranteed
        - Interactive: Fast-paced clicking game with moving targets
        - Visual: Snow-covered hunt area with animated yetis

        🛸 ROCKET LAUNCH BONUS:
        - Trigger: 5 UFOs (🛸) anywhere on reels
        - Chance: 0.3% per spin (rarest bonus)
        - Gameplay: Time rocket launch with power meter
        - Attempts: 3 launch attempts
        - Power Zones: Perfect (45-55%) = 10x, Good (35-65%) = 5x, Warning (25-75%) = 2x, Danger = 0.5x
        - Minimum Win: 100x bet guaranteed
        - Interactive: Timing-based skill game
        - Visual: Animated rocket with color-coded power meter

        🎯 BONUS TRIGGERS & MECHANICS:
        - Independent of free spins (can't trigger during free spins)
        - Each bonus has unique entry animation and soundtrack
        - Guaranteed minimum wins to ensure player satisfaction
        - Progressive difficulty and rewards
        - Compatible with turbo mode (faster intro/outro)
        - Achievement system for bonus completion
        - Auto-spin pauses during bonus rounds

        🎮 USER EXPERIENCE ENHANCEMENTS:
        - Keyboard shortcuts: SPACE (spin), T (turbo), M (mute)
        - Visual feedback for all controls
        - Settings panel with toggle switches
        - Audio controls in header and settings
        - Turbo mode indicator overlay
        - Smooth transitions between modes
        - Bonus round visual takeover of game area

        🎯 SYMBOL FREQUENCY (Lower = Rarer):
        - 🏔️ Wild Yeti: 1% (Very Rare) - 100x max payout + Yeti Hunt trigger
        - 🚀 Rocket: 3% (Rare) - 50x max payout + Moon Mission trigger
        - 🌙 Moon/Scatter: 4% (Rare) - 30x max payout + Free Spins
        - 🪙 Coin: 8% (Uncommon) - 20x max payout
        - ⭐ Star: 15% (Common) - 15x max payout
        - 🪐 Planet: 20% (Common) - 10x max payout
        - 👽 Alien: 25% (Very Common) - 8x max payout
        - 🛸 UFO: 24% (Very Common) - 5x max payout + Rocket Launch trigger

        🌙 FREE SPINS SYSTEM:
        - 3 Moons: 10 free spins (1x multiplier)
        - 4 Moons: 15 free spins (2x multiplier)
        - 5 Moons: 20 free spins (2x multiplier)
        - No bet required during free spins
        - Automatic execution with visual feedback
        - Can't retrigger during free spins mode
        - Special audio effects and celebrations

        🔊 AUDIO SPECIFICATIONS:
        - Master Volume: 0-100% with visual slider
        - SFX Volume: 80% of master volume
        - Music Volume: 30% of master volume
        - Frequency ranges: 50Hz-1300Hz for musical tones
        - Sound types: sine, sawtooth, square waves
        - Audio context auto-resume on user interaction

        ⚡ TURBO MODE SPECIFICATIONS:
        - Reel spin duration: 3x faster (600-1200ms)
        - Effect display time: 3x faster (500ms)
        - Auto-spin delay: ~3x faster (700ms)
        - Free spins delay: 2x faster (800ms)
        - Bonus intro/outro: 2x faster
        - Visual indicators: yellow border, flash animation
        - Compatible with all game modes

        📊 HOW IT WORKS:
        1. Each spin uses weighted random selection
        2. RTP monitoring adjusts probabilities slightly
        3. If RTP > 96.5%, slightly favor house
        4. If RTP < 95.5%, slightly favor player
        5. Near-miss logic adds excitement (no payout)
        6. Bonus triggers checked after each spin
        7. House always has mathematical advantage long-term
        8. Memory cleanup prevents performance degradation
        9. Audio feedback enhances user engagement
        10. Turbo mode maintains all features at higher speed
        11. Bonus rounds provide major engagement spikes

        💰 REALISTIC ECONOMICS:
        - Max bet: 100 MY (realistic for crypto gaming)
        - Payouts: 90% reduced from original (mathematically viable)
        - Bonus minimum wins: Guaranteed to prevent frustration
        - Achievement thresholds: Adjusted for new economy
        - Big wins: Rare but possible (realistic gambling)
        - Most spins: Small losses (industry standard)
        - Bonus frequency: Rare enough to be special (1-2% combined)

        🎮 COMPLETE CASINO EXPERIENCE:
        - No hanging after multiple spins
        - Smooth free spins execution
        - Interactive bonus rounds with skill elements
        - Memory efficient particle systems
        - Mobile-friendly optimizations
        - Automatic cleanup systems
        - Rich audio feedback system
        - Customizable speed with turbo mode
        - Intuitive controls and keyboard shortcuts
        - Achievement system with bonus tracking
        - Professional casino-grade mathematics

        This system now provides the most complete slot machine
        experience possible with realistic mathematics, immersive
        audio, flexible speed options, interactive bonus rounds,
        and stable performance for extended play sessions.
        
        The bonus rounds break up the traditional slot gameplay
        with engaging mini-games that require different skills:
        - Strategy (Moon Mission)
        - Reflexes (Yeti Hunt)  
        - Timing (Rocket Launch)
        
        This creates a varied and exciting gaming experience
        that maintains player engagement far beyond traditional
        slot machines while preserving the MoonYetis theme
        and mathematical integrity.
        */
    </script>
    
    <!-- Wallet CSS Styles -->
    <style>
        /* === WALLET SELECTOR MODAL === */
        .wallet-selector-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .wallet-selector-content {
            background: var(--dark);
            padding: 2.5rem;
            border-radius: var(--border-radius);
            border: 2px solid var(--primary);
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-xl);
        }

        .wallet-selector-content h3 {
            margin-bottom: 0.5rem;
            color: var(--light);
            font-size: 1.5rem;
        }

        .wallet-selector-content p {
            color: var(--gray-400);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .wallet-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .wallet-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--gradient-glass);
            border: 2px solid transparent;
            border-radius: var(--border-radius-sm);
            color: var(--light);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .wallet-btn:hover:not(.disabled) {
            transform: translateY(-2px);
            border-color: var(--primary);
            background: var(--gradient-primary);
        }

        .wallet-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--gray-800);
        }

        .wallet-status {
            font-size: 0.9rem;
            font-weight: normal;
        }

        .cancel-btn {
            padding: 0.75rem 2rem;
            background: transparent;
            border: 1px solid var(--gray-600);
            border-radius: var(--border-radius-sm);
            color: var(--gray-400);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cancel-btn:hover {
            border-color: var(--gray-400);
            color: var(--light);
        }

        /* === WALLET CONNECTED UI === */
        .wallet-connected {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: var(--gradient-glass);
            border: 1px solid var(--secondary);
            border-radius: var(--border-radius-sm);
            flex-wrap: wrap;
        }

        .wallet-type {
            font-weight: 600;
            color: var(--secondary);
            font-size: 0.9rem;
        }

        .wallet-address {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--gray-300);
            background: rgba(0, 0, 0, 0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }

        .disconnect-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--gray-600);
            border-radius: var(--border-radius-sm);
            color: var(--gray-400);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .disconnect-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .connect-wallet-btn {
            padding: 1rem 2rem;
            background: var(--gradient-primary);
            border: none;
            border-radius: var(--border-radius-sm);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.3);
        }

        /* === NEUTRAL MESSAGE TYPE === */
        .message.neutral {
            background: var(--gray-700);
            color: var(--light);
            border: 1px solid var(--gray-500);
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .wallet-selector-content {
                padding: 2rem;
                margin: 1rem;
            }
            
            .wallet-connected {
                flex-direction: column;
                text-align: center;
                gap: 0.75rem;
            }
            
            .wallet-btn {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }
        }
    </style>

    <!-- Modularized Scripts -->
    <script src="js/wallet-manager-v3.js"></script>
    <script src="js/slot-machine.js"></script>
    <script src="js/wallet-integration-v3.js"></script>
    
    <!-- Backend Test Script -->
    <script>
        async function testBackendConnection() {
            console.log('🔗 Connecting wallet for real game play...');
            
            // Check if wallets are available
            if (typeof window.unisat === 'undefined' && typeof window.okxwallet === 'undefined') {
                const useDemo = confirm('❌ No hay wallets disponibles. ¿Quieres jugar en modo demo con tokens virtuales?\n\n• ✅ Sí - Jugar en modo demo\n• ❌ No - Instalar wallet primero');
                if (useDemo) {
                    // Activate demo mode
                    if (typeof slotMachine !== 'undefined' && slotMachine.connectWallet) {
                        slotMachine.connectWallet('demo');
                    }
                }
                return;
            }
            
            try {
                let wallet, address, balance, signature, walletType;
                
                // Try UniSat first, then OKX
                if (typeof window.unisat !== 'undefined') {
                    console.log('🦄 Connecting UniSat...');
                    walletType = 'unisat';
                    wallet = window.unisat;
                    
                    const accounts = await wallet.requestAccounts();
                    address = accounts[0];
                    balance = await wallet.getBalance();
                    
                } else if (typeof window.okxwallet !== 'undefined') {
                    console.log('🟠 Connecting OKX...');
                    walletType = 'okx';
                    wallet = window.okxwallet.bitcoin;
                    
                    const accounts = await wallet.requestAccounts();
                    address = accounts[0];
                    balance = await wallet.getBalance();
                }
                
                console.log('✅ Address:', address);
                console.log('💰 Balance:', balance);
                
                // Create signature
                const message = `MoonYetis Slots Authentication
Address: ${address}
Time: ${new Date().toISOString()}
Nonce: ${Math.random().toString(36).substring(2, 15)}`;
                
                console.log('✍️ Requesting signature...');
                if (walletType === 'unisat') {
                    signature = await wallet.signMessage(message);
                } else {
                    signature = await wallet.signMessage(message, 'ecdsa');
                }
                console.log('✅ Signature obtained:', signature.substring(0, 40) + '...');
                
                // SIMULATE BACKEND SUCCESS (since we don't have a real backend)
                console.log('🚧 DEVELOPMENT MODE: Simulating successful backend verification');
                
                // Update game state
                gameState.connectedWallet = true;
                gameState.walletAddress = address;
                gameState.walletType = walletType;
                gameState.balance = balance.total || 1000000; // Use real balance or fallback
                gameState.demoMode = false;
                
                // Update UI elements
                updateWalletUI(address, walletType, balance);
                
                // Update slot machine UI if available
                if (typeof slotMachine !== 'undefined' && slotMachine.updateUI) {
                    slotMachine.updateUI();
                }
                
                // Show success message
                const successMsg = `🎉 ¡WALLET CONECTADA EXITOSAMENTE!

🦄 Wallet: ${walletType.toUpperCase()}
📍 Address: ${address.substring(0, 8)}...${address.substring(-6)}
💰 Balance: ${Math.floor(balance.total / 100000000 * 100000) / 100000} BTC
🎮 ¡Listo para jugar con tokens reales!`;
                
                alert(successMsg);
                console.log('✅ Wallet connection completed successfully');
                
            } catch (error) {
                console.error('❌ Connection error:', error);
                alert(`❌ Error conectando wallet: ${error.message}

Verifica que tu wallet esté desbloqueada y autoriza la conexión.`);
            }
        }
        
        // Update wallet UI elements
        function updateWalletUI(address, walletType, balance) {
            console.log('🎨 Updating wallet UI...');
            
            // Update connection status
            const statusEl = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            if (statusEl && statusText) {
                statusEl.className = 'status-indicator connected';
                statusText.textContent = `Connected (${walletType.toUpperCase()})`;
            }
            
            // Update wallet button
            const walletBtn = document.getElementById('connectWallet');
            const walletBtnText = document.getElementById('walletBtnText');
            if (walletBtn && walletBtnText) {
                const walletIcon = walletType === 'unisat' ? '🦄' : '🟠';
                walletBtnText.textContent = `${walletIcon} ${address.substring(0, 6)}...${address.substring(-4)}`;
                walletBtn.onclick = disconnectWallet;
                walletBtn.title = 'Click to disconnect wallet';
            }
            
            // Update balance display
            const balanceDisplay = document.getElementById('balanceDisplay');
            const balanceEl = document.getElementById('balance');
            if (balanceDisplay && balanceEl) {
                balanceDisplay.style.display = 'block';
                const btcBalance = (balance.total / 100000000).toFixed(8);
                balanceEl.textContent = `${balance.total} sats (${btcBalance} BTC)`;
            }
            
            // Hide any demo mode indicators
            const devModeIndicator = document.getElementById('devModeIndicator');
            if (devModeIndicator) {
                devModeIndicator.style.display = 'none';
            }
            
            console.log('✅ Wallet UI updated successfully');
        }
        
        // Disconnect wallet function
        function disconnectWallet() {
            console.log('🔌 Disconnecting wallet...');
            
            // Reset game state
            gameState.connectedWallet = false;
            gameState.walletAddress = null;
            gameState.walletType = null;
            gameState.balance = 0;
            gameState.demoMode = true;
            
            // Reset UI elements
            const statusEl = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            if (statusEl && statusText) {
                statusEl.className = 'status-indicator disconnected';
                statusText.textContent = 'Not Connected';
            }
            
            const walletBtn = document.getElementById('connectWallet');
            const walletBtnText = document.getElementById('walletBtnText');
            if (walletBtn && walletBtnText) {
                walletBtnText.textContent = 'Connect Wallet';
                walletBtn.onclick = testBackendConnection;
                walletBtn.title = 'Connect your wallet to start playing';
            }
            
            const balanceDisplay = document.getElementById('balanceDisplay');
            if (balanceDisplay) {
                balanceDisplay.style.display = 'none';
            }
            
            // Update slot machine UI if available
            if (typeof slotMachine !== 'undefined' && slotMachine.updateUI) {
                slotMachine.updateUI();
            }
            
            alert('🔌 Wallet desconectada. Vuelve al modo demo.');
            console.log('✅ Wallet disconnected successfully');
        }
        
        // Fix reel symbols display with PNG images
        function createWorkingReels() {
            console.log('🎲 Creating working reels with PNG images...');
            
            const container = document.getElementById('reelsContainer');
            if (!container) {
                console.warn('⚠️ Reels container not found');
                return;
            }
            
            // Clear existing reels
            container.innerHTML = '';
            
            // Symbol configuration with PNG images and emoji fallbacks
            const SYMBOL_CONFIG = [
                { id: 'yeti', name: 'Yeti Wild', image: 'assets/symbols/yeti-wild.png', emoji: '🏔️', rarity: 'legendary' },
                { id: 'rocket', name: 'Rocket High', image: 'assets/symbols/rocket-high.png', emoji: '🚀', rarity: 'high' },
                { id: 'moon', name: 'Moon Scatter', image: 'assets/symbols/moon-scatter.png', emoji: '🌙', rarity: 'special' },
                { id: 'coin', name: 'Coin Medium', image: 'assets/symbols/coin-medium.png', emoji: '🪙', rarity: 'medium' },
                { id: 'star', name: 'Star Medium', image: 'assets/symbols/star-medium.png', emoji: '⭐', rarity: 'medium' },
                { id: 'planet', name: 'Planet Low', image: 'assets/symbols/planet-low.png', emoji: '🪐', rarity: 'low' },
                { id: 'alien', name: 'Alien Bonus', image: 'assets/symbols/alien-bonus.png', emoji: '👽', rarity: 'bonus' },
                { id: 'ufo', name: 'UFO Special', image: 'assets/symbols/ufo-special.png', emoji: '🛸', rarity: 'special' }
            ];
            
            // Create 5 reels
            for (let i = 0; i < 5; i++) {
                const reel = document.createElement('div');
                reel.className = 'reel';
                reel.id = `reel-${i}`;
                
                // Create 3 symbols per reel
                for (let j = 0; j < 3; j++) {
                    const symbol = document.createElement('div');
                    symbol.className = 'symbol';
                    
                    // Select random symbol
                    const randomSymbolConfig = SYMBOL_CONFIG[Math.floor(Math.random() * SYMBOL_CONFIG.length)];
                    
                    // Create image element with fallback
                    const img = document.createElement('img');
                    img.src = randomSymbolConfig.image;
                    img.alt = randomSymbolConfig.name;
                    img.title = randomSymbolConfig.name;
                    img.dataset.symbolId = randomSymbolConfig.id;
                    img.dataset.emoji = randomSymbolConfig.emoji;
                    
                    // Image styling
                    img.style.width = '50px';
                    img.style.height = '50px';
                    img.style.objectFit = 'contain';
                    img.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))';
                    
                    // Error handling - fallback to emoji
                    img.onerror = function() {
                        console.warn(`⚠️ Failed to load image: ${randomSymbolConfig.image}`);
                        this.style.display = 'none';
                        const fallback = document.createElement('span');
                        fallback.textContent = randomSymbolConfig.emoji;
                        fallback.style.fontSize = '2rem';
                        fallback.title = randomSymbolConfig.name + ' (fallback)';
                        this.parentNode.appendChild(fallback);
                    };
                    
                    // Symbol container styling
                    symbol.style.display = 'flex';
                    symbol.style.alignItems = 'center';
                    symbol.style.justifyContent = 'center';
                    symbol.style.height = '66px';
                    symbol.style.borderBottom = '1px solid #374151';
                    symbol.style.background = 'linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%)';
                    symbol.style.position = 'relative';
                    
                    // Add glow effect for special symbols
                    if (randomSymbolConfig.rarity === 'legendary') {
                        symbol.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                    } else if (randomSymbolConfig.rarity === 'special') {
                        symbol.style.boxShadow = '0 0 8px rgba(138, 43, 226, 0.4)';
                    }
                    
                    symbol.appendChild(img);
                    reel.appendChild(symbol);
                }
                
                container.appendChild(reel);
            }
            
            console.log('✅ Working reels created with PNG images and fallbacks');
            
            // Verify images loaded
            setTimeout(() => {
                const images = container.querySelectorAll('img');
                let loadedCount = 0;
                images.forEach(img => {
                    if (img.complete && img.naturalHeight !== 0) {
                        loadedCount++;
                    }
                });
                console.log(`📊 ${loadedCount}/${images.length} images loaded successfully`);
            }, 1000);
        }
        
        // Fix paytable to show PNG images
        function updatePaytableWithImages() {
            console.log('🎨 Updating paytable with PNG images...');
            
            const paytableSymbols = document.querySelectorAll('.paytable-symbol');
            
            paytableSymbols.forEach(symbolEl => {
                // Get symbol type from class
                let symbolType = 'yeti'; // default
                if (symbolEl.classList.contains('symbol-rocket')) symbolType = 'rocket';
                else if (symbolEl.classList.contains('symbol-moon')) symbolType = 'moon';
                else if (symbolEl.classList.contains('symbol-coin')) symbolType = 'coin';
                else if (symbolEl.classList.contains('symbol-star')) symbolType = 'star';
                else if (symbolEl.classList.contains('symbol-planet')) symbolType = 'planet';
                else if (symbolEl.classList.contains('symbol-alien')) symbolType = 'alien';
                else if (symbolEl.classList.contains('symbol-ufo')) symbolType = 'ufo';
                
                // Map symbol types to file names
                const imageMap = {
                    'yeti': 'yeti-wild.png',
                    'rocket': 'rocket-high.png',
                    'moon': 'moon-scatter.png',
                    'coin': 'coin-medium.png',
                    'star': 'star-medium.png',
                    'planet': 'planet-low.png',
                    'alien': 'alien-bonus.png',
                    'ufo': 'ufo-special.png'
                };
                
                // Clear existing content
                symbolEl.innerHTML = '';
                
                // Create image element
                const img = document.createElement('img');
                img.src = `assets/symbols/${imageMap[symbolType]}`;
                img.alt = symbolType;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                
                // Error fallback
                img.onerror = function() {
                    console.warn(`⚠️ Paytable image failed: ${this.src}`);
                    this.style.display = 'none';
                    const fallback = document.createElement('div');
                    fallback.textContent = symbolType.charAt(0).toUpperCase();
                    fallback.style.display = 'flex';
                    fallback.style.alignItems = 'center';
                    fallback.style.justifyContent = 'center';
                    fallback.style.width = '100%';
                    fallback.style.height = '100%';
                    fallback.style.fontSize = '0.8rem';
                    fallback.style.fontWeight = 'bold';
                    this.parentNode.appendChild(fallback);
                };
                
                symbolEl.appendChild(img);
            });
            
            console.log('✅ Paytable updated with PNG images');
        }
        
        // Real wallet SPIN function
        function realWalletSpin() {
            console.log('🎰 Real wallet spin initiated...');
            
            // Check if wallet is connected
            if (!gameState.connectedWallet) {
                alert('⚠️ ¡Conecta tu wallet primero para apostar con tokens reales!');
                return;
            }
            
            // Check if already spinning
            if (gameState.isSpinning) {
                console.log('⚠️ Ya hay un giro en progreso');
                return;
            }
            
            // Get current bet amount (in MY tokens)
            const currentBet = gameState.currentBet || 250; // default bet
            const totalBet = currentBet * (gameState.activeLines || 25);
            
            // Check if user has enough balance
            if (gameState.balance < totalBet) {
                alert(`💸 ¡Saldo insuficiente! 
                
Necesitas: ${totalBet} sats
Tu balance: ${gameState.balance} sats

Reduce tu apuesta o añade más fondos a tu wallet.`);
                return;
            }
            
            console.log(`💰 Spinning with ${totalBet} sats (${currentBet} x ${gameState.activeLines || 25} lines)`);
            
            // Set spinning state
            gameState.isSpinning = true;
            
            // Update spin button
            const spinBtn = document.getElementById('spinBtn');
            const spinBtnText = document.getElementById('spinBtnText');
            if (spinBtn && spinBtnText) {
                spinBtn.disabled = true;
                spinBtn.classList.add('spinning');
                spinBtnText.textContent = '🔄 SPINNING...';
            }
            
            // Deduct bet from balance
            gameState.balance -= totalBet;
            gameState.totalSpins = (gameState.totalSpins || 0) + 1;
            gameState.totalWagered = (gameState.totalWagered || 0) + totalBet;
            
            // Update UI immediately
            updateWalletUI(gameState.walletAddress, gameState.walletType, { total: gameState.balance });
            
            // Animate reels
            animateReels();
            
            // Simulate spin duration - wait for animations to finish
            setTimeout(() => {
                console.log('🎯 Generating final results...');
                
                // Generate random results
                const results = generateSpinResults();
                
                // Display results with a nice reveal effect
                setTimeout(() => {
                    displaySpinResults(results);
                }, 200); // Small delay after animations stop
                
                // Calculate winnings
                const winAmount = calculateWinnings(results, currentBet);
                
                if (winAmount > 0) {
                    // Add winnings to balance
                    gameState.balance += winAmount;
                    gameState.totalWon = (gameState.totalWon || 0) + winAmount;
                    gameState.lastWin = winAmount;
                    
                    // Update biggest win
                    if (winAmount > (gameState.biggestWin || 0)) {
                        gameState.biggestWin = winAmount;
                    }
                    
                    // Show win message
                    alert(`🎉 ¡GANASTE ${winAmount} SATS!
                    
Tu nuevo balance: ${gameState.balance} sats
¡Sigue jugando!`);
                    
                    // Highlight winning symbols
                    highlightWinningCombination(results);
                    
                    console.log(`🏆 WIN: ${winAmount} sats`);
                } else {
                    console.log('😔 No win this spin');
                }
                
                // Reset spinning state
                gameState.isSpinning = false;
                
                // Update UI
                updateWalletUI(gameState.walletAddress, gameState.walletType, { total: gameState.balance });
                
                // Reset spin button
                if (spinBtn && spinBtnText) {
                    spinBtn.disabled = false;
                    spinBtn.classList.remove('spinning');
                    spinBtnText.textContent = '🎯 SPIN';
                }
                
                console.log(`💰 Balance after spin: ${gameState.balance} sats`);
                
            }, 2000); // 2 second spin animation
        }
        
        // Create realistic slot machine reel animation
        function animateReels() {
            console.log('🎰 Starting realistic slot machine animation...');
            
            const reels = document.querySelectorAll('.reel');
            
            reels.forEach((reel, reelIndex) => {
                createReelStrip(reel, reelIndex);
                startReelSpinning(reel, reelIndex);
            });
        }
        
        // Create a continuous reel strip with multiple symbols
        function createReelStrip(reel, reelIndex) {
            // Store original symbols
            const originalSymbols = Array.from(reel.children);
            
            // Create reel strip container
            const reelStrip = document.createElement('div');
            reelStrip.className = 'reel-strip';
            reelStrip.style.position = 'relative';
            reelStrip.style.transition = 'none';
            reelStrip.style.top = '0px';
            
            // Symbol configuration for PNG images
            const SYMBOL_CONFIG = [
                { id: 'yeti', image: 'assets/symbols/yeti-wild.png', emoji: '🏔️' },
                { id: 'rocket', image: 'assets/symbols/rocket-high.png', emoji: '🚀' },
                { id: 'moon', image: 'assets/symbols/moon-scatter.png', emoji: '🌙' },
                { id: 'coin', image: 'assets/symbols/coin-medium.png', emoji: '🪙' },
                { id: 'star', image: 'assets/symbols/star-medium.png', emoji: '⭐' },
                { id: 'planet', image: 'assets/symbols/planet-low.png', emoji: '🪐' },
                { id: 'alien', image: 'assets/symbols/alien-bonus.png', emoji: '👽' },
                { id: 'ufo', image: 'assets/symbols/ufo-special.png', emoji: '🛸' }
            ];
            
            // Create a long strip of symbols (20+ symbols for continuous scroll)
            for (let i = 0; i < 25; i++) {
                const symbolConfig = SYMBOL_CONFIG[Math.floor(Math.random() * SYMBOL_CONFIG.length)];
                const symbolDiv = document.createElement('div');
                symbolDiv.className = 'symbol';
                symbolDiv.style.height = '66px';
                symbolDiv.style.display = 'flex';
                symbolDiv.style.alignItems = 'center';
                symbolDiv.style.justifyContent = 'center';
                symbolDiv.style.borderBottom = '1px solid #374151';
                symbolDiv.style.background = 'linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%)';
                
                // Create image element
                const img = document.createElement('img');
                img.src = symbolConfig.image;
                img.style.width = '50px';
                img.style.height = '50px';
                img.style.objectFit = 'contain';
                img.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))';
                img.dataset.symbolId = symbolConfig.id;
                
                // Error fallback to emoji
                img.onerror = function() {
                    this.style.display = 'none';
                    const fallback = document.createElement('span');
                    fallback.textContent = symbolConfig.emoji;
                    fallback.style.fontSize = '2rem';
                    this.parentNode.appendChild(fallback);
                };
                
                symbolDiv.appendChild(img);
                reelStrip.appendChild(symbolDiv);
            }
            
            // Clear reel and add strip
            reel.innerHTML = '';
            reel.appendChild(reelStrip);
            
            // Store references for later
            reel.dataset.originalContent = JSON.stringify(originalSymbols.map(s => s.innerHTML));
            reel.dataset.reelStrip = 'true';
        }
        
        // Start realistic spinning animation
        function startReelSpinning(reel, reelIndex) {
            const reelStrip = reel.querySelector('.reel-strip');
            if (!reelStrip) return;
            
            const symbolHeight = 66; // Height of each symbol
            const totalSymbols = reelStrip.children.length;
            const maxScroll = symbolHeight * (totalSymbols - 3); // Keep 3 symbols visible
            
            let currentPosition = 0;
            let isSpinning = true;
            const spinSpeed = 8; // Pixels per frame
            const spinDuration = 1500 + (reelIndex * 300); // Staggered stopping
            
            // Add motion blur effect
            reel.style.filter = 'blur(1px)';
            reel.style.opacity = '0.9';
            
            console.log(`🎰 Reel ${reelIndex + 1}: Starting spin for ${spinDuration}ms`);
            
            // Spinning animation loop
            const spinInterval = setInterval(() => {
                if (isSpinning) {
                    currentPosition += spinSpeed;
                    
                    // Loop back to top when reaching bottom
                    if (currentPosition >= maxScroll) {
                        currentPosition = 0;
                    }
                    
                    reelStrip.style.transform = `translateY(-${currentPosition}px)`;
                }
            }, 16); // ~60fps
            
            // Stop spinning after duration
            setTimeout(() => {
                isSpinning = false;
                clearInterval(spinInterval);
                
                // Smooth deceleration to final position
                const finalPosition = Math.floor(currentPosition / symbolHeight) * symbolHeight;
                reelStrip.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                reelStrip.style.transform = `translateY(-${finalPosition}px)`;
                
                // Remove blur and restore clarity
                reel.style.filter = 'none';
                reel.style.opacity = '1';
                
                console.log(`🛑 Reel ${reelIndex + 1}: Stopped at position ${finalPosition}`);
                
                // If this is the last reel, finish the animation
                if (reelIndex === 4) {
                    setTimeout(() => {
                        finishReelAnimation();
                    }, 500);
                }
            }, spinDuration);
        }
        
        // Finish animation and restore normal reels
        function finishReelAnimation() {
            console.log('🎯 Finishing reel animation and restoring final symbols...');
            
            const reels = document.querySelectorAll('.reel');
            reels.forEach((reel, index) => {
                // Add final stopping effect
                reel.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    reel.style.transition = 'transform 0.2s ease-out';
                    reel.style.transform = 'scale(1)';
                }, 100);
            });
            
            // Small delay before showing final results
            setTimeout(() => {
                console.log('✨ Animation complete, showing final results');
            }, 200);
        }
        
        // Generate random spin results
        function generateSpinResults() {
            const symbols = ['yeti', 'rocket', 'moon', 'coin', 'star', 'planet', 'alien', 'ufo'];
            const results = [];
            
            for (let reel = 0; reel < 5; reel++) {
                const reelResults = [];
                for (let pos = 0; pos < 3; pos++) {
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    reelResults.push(randomSymbol);
                }
                results.push(reelResults);
            }
            
            console.log('🎲 Spin results:', results);
            return results;
        }
        
        // Display spin results on reels
        function displaySpinResults(results) {
            const SYMBOL_CONFIG = {
                'yeti': { image: 'assets/symbols/yeti-wild.png', emoji: '🏔️' },
                'rocket': { image: 'assets/symbols/rocket-high.png', emoji: '🚀' },
                'moon': { image: 'assets/symbols/moon-scatter.png', emoji: '🌙' },
                'coin': { image: 'assets/symbols/coin-medium.png', emoji: '🪙' },
                'star': { image: 'assets/symbols/star-medium.png', emoji: '⭐' },
                'planet': { image: 'assets/symbols/planet-low.png', emoji: '🪐' },
                'alien': { image: 'assets/symbols/alien-bonus.png', emoji: '👽' },
                'ufo': { image: 'assets/symbols/ufo-special.png', emoji: '🛸' }
            };
            
            for (let reelIndex = 0; reelIndex < 5; reelIndex++) {
                const reel = document.getElementById(`reel-${reelIndex}`);
                if (reel) {
                    const symbols = reel.querySelectorAll('.symbol');
                    for (let symbolIndex = 0; symbolIndex < 3; symbolIndex++) {
                        if (symbols[symbolIndex]) {
                            const symbolType = results[reelIndex][symbolIndex];
                            const config = SYMBOL_CONFIG[symbolType];
                            
                            // Clear and update symbol
                            symbols[symbolIndex].innerHTML = '';
                            symbols[symbolIndex].classList.remove('winning');
                            
                            const img = document.createElement('img');
                            img.src = config.image;
                            img.style.width = '50px';
                            img.style.height = '50px';
                            img.style.objectFit = 'contain';
                            img.dataset.symbolId = symbolType;
                            
                            img.onerror = function() {
                                this.style.display = 'none';
                                const fallback = document.createElement('span');
                                fallback.textContent = config.emoji;
                                fallback.style.fontSize = '2rem';
                                this.parentNode.appendChild(fallback);
                            };
                            
                            symbols[symbolIndex].appendChild(img);
                        }
                    }
                }
            }
        }
        
        // Calculate winnings based on results
        function calculateWinnings(results, baseBet) {
            // Simple calculation: check center line
            const centerLine = [
                results[0][1], // center of reel 1
                results[1][1], // center of reel 2  
                results[2][1], // center of reel 3
                results[3][1], // center of reel 4
                results[4][1]  // center of reel 5
            ];
            
            // Count consecutive matching symbols from left
            let consecutiveCount = 1;
            let winSymbol = centerLine[0];
            
            for (let i = 1; i < centerLine.length; i++) {
                if (centerLine[i] === winSymbol || winSymbol === 'yeti') { // yeti is wild
                    consecutiveCount++;
                } else {
                    break;
                }
            }
            
            // Calculate multiplier based on symbol and count
            let multiplier = 0;
            if (consecutiveCount >= 5) {
                switch (winSymbol) {
                    case 'yeti': multiplier = 100; break;
                    case 'rocket': multiplier = 50; break;
                    case 'moon': multiplier = 30; break;
                    case 'coin': multiplier = 20; break;
                    case 'star': multiplier = 15; break;
                    case 'planet': multiplier = 10; break;
                    case 'alien': multiplier = 8; break;
                    case 'ufo': multiplier = 5; break;
                }
            } else if (consecutiveCount >= 4) {
                multiplier = Math.floor(multiplier * 0.25);
            } else if (consecutiveCount >= 3) {
                multiplier = Math.floor(multiplier * 0.1);
            }
            
            const winAmount = Math.floor(baseBet * multiplier);
            console.log(`🎯 Win calculation: ${consecutiveCount}x ${winSymbol} = ${multiplier}x = ${winAmount} sats`);
            
            return winAmount;
        }
        
        // Highlight winning combination
        function highlightWinningCombination(results) {
            // Simple highlight of center line if there's a win
            for (let i = 0; i < 5; i++) {
                const reel = document.getElementById(`reel-${i}`);
                if (reel) {
                    const centerSymbol = reel.children[1]; // middle symbol
                    if (centerSymbol) {
                        centerSymbol.classList.add('winning');
                        centerSymbol.style.boxShadow = '0 0 15px #FFE66D';
                        centerSymbol.style.border = '2px solid #FFE66D';
                    }
                }
            }
            
            // Remove highlight after 3 seconds
            setTimeout(() => {
                document.querySelectorAll('.symbol.winning').forEach(symbol => {
                    symbol.classList.remove('winning');
                    symbol.style.boxShadow = '';
                    symbol.style.border = '';
                });
            }, 3000);
        }

        // Test reel creation function
        function testReelCreation() {
            console.log('🧪 Testing reel creation...');
            createWorkingReels();
            updatePaytableWithImages();
            
            // Test if symbols are visible
            setTimeout(() => {
                const symbols = document.querySelectorAll('.symbol');
                console.log(`📊 Created ${symbols.length} symbols`);
                
                let visibleCount = 0;
                symbols.forEach((symbol, index) => {
                    if (symbol.textContent && symbol.textContent.trim() !== '') {
                        visibleCount++;
                    } else {
                        console.warn(`⚠️ Symbol ${index} is empty:`, symbol);
                    }
                });
                
                console.log(`✅ ${visibleCount}/${symbols.length} symbols are visible`);
                
                if (visibleCount === symbols.length) {
                    alert('🎉 ¡Rodillos funcionando! Ahora puedes hacer apuestas reales.');
                } else {
                    alert(`⚠️ Solo ${visibleCount} de ${symbols.length} símbolos son visibles. Revisando...`);
                }
            }, 500);
        }

        // Add event listeners for wallet buttons
        document.addEventListener('DOMContentLoaded', function() {
            const testBtn = document.getElementById('testBackend');
            if (testBtn) {
                testBtn.addEventListener('click', testBackendConnection);
            }
            
            // Add fix reels button listener
            const fixReelsBtn = document.getElementById('fixReels');
            if (fixReelsBtn) {
                fixReelsBtn.addEventListener('click', testReelCreation);
            }
            
            // Add test animation button listener
            const testAnimationBtn = document.getElementById('testAnimation');
            if (testAnimationBtn) {
                testAnimationBtn.addEventListener('click', function() {
                    console.log('🎬 Testing animation only...');
                    animateReels();
                    
                    // Show completion message
                    setTimeout(() => {
                        alert('🎬 Animación completada! ¿Se veían los símbolos girando suavemente?');
                    }, 2000);
                });
            }
            
            // Auto-create reels and fix paytable on page load
            setTimeout(() => {
                console.log('🔄 Auto-creating reels and fixing paytable on page load...');
                createWorkingReels();
                updatePaytableWithImages();
                
                // Connect SPIN button to real wallet system
                const spinBtn = document.getElementById('spinBtn');
                if (spinBtn) {
                    console.log('🎯 Connecting SPIN button to real wallet system...');
                    
                    // Remove existing listeners
                    const newSpinBtn = spinBtn.cloneNode(true);
                    spinBtn.parentNode.replaceChild(newSpinBtn, spinBtn);
                    
                    // Add real wallet spin listener
                    newSpinBtn.addEventListener('click', function() {
                        console.log('🎰 SPIN button clicked - using real wallet system');
                        realWalletSpin();
                    });
                    
                    console.log('✅ SPIN button connected to real wallet system');
                } else {
                    console.warn('⚠️ SPIN button not found');
                }
            }, 2000);
            
            // Connect main wallet button to modular system
            const mainWalletBtn = document.getElementById('connectWallet');
            if (mainWalletBtn) {
                console.log('🔗 Connecting main wallet button to modular system');
                
                // Remove any existing listeners by cloning the node
                const newBtn = mainWalletBtn.cloneNode(true);
                mainWalletBtn.parentNode.replaceChild(newBtn, mainWalletBtn);
                
                // Add direct wallet connection (same as testBackend)
                newBtn.addEventListener('click', function() {
                    console.log('🔗 Main Connect button clicked - using direct connection');
                    testBackendConnection(); // Use the same function that works
                });
                
                console.log('✅ Main wallet button connected to modular system');
            } else {
                console.warn('⚠️ Main wallet button not found');
            }
        });
    </script>
    
    <!-- Advanced Wallet Panel JavaScript -->
    <script>
        // Notification Audio Manager - Dedicated sound system for wallet notifications
        class NotificationAudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = new Map();
                this.isInitialized = false;
                this.volume = 0.7;
                this.enabled = true;
                
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    // Initialize Web Audio Context for notification sounds
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createNotificationSounds();
                    this.isInitialized = true;
                    console.log('🔊 Notification audio system initialized');
                } catch (error) {
                    console.warn('⚠️ Notification audio not supported:', error);
                    this.enabled = false;
                }
            }
            
            createNotificationSounds() {
                // Create different sounds for different notification types
                this.sounds.set('success', () => this.createSuccessSound());
                this.sounds.set('info', () => this.createInfoSound());
                this.sounds.set('warning', () => this.createWarningSound());
                this.sounds.set('error', () => this.createErrorSound());
                this.sounds.set('progress', () => this.createProgressSound());
                this.sounds.set('deposit_complete', () => this.createDepositCompleteSound());
                this.sounds.set('confirmation', () => this.createConfirmationSound());
                this.sounds.set('connection', () => this.createConnectionSound());
            }
            
            // Success sound - Major chord progression
            createSuccessSound() {
                if (!this.canPlayAudio()) return;
                
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5 (C major chord)
                this.playChord(notes, 0.6, 'sine');
            }
            
            // Info sound - Single pleasant tone
            createInfoSound() {
                if (!this.canPlayAudio()) return;
                
                this.playTone(880, 0.3, 'sine', 0.15); // A5 note
            }
            
            // Warning sound - Two-tone alert
            createWarningSound() {
                if (!this.canPlayAudio()) return;
                
                this.playTone(800, 0.4, 'square', 0.1);
                setTimeout(() => {
                    this.playTone(600, 0.4, 'square', 0.1);
                }, 150);
            }
            
            // Error sound - Descending tones
            createErrorSound() {
                if (!this.canPlayAudio()) return;
                
                this.playTone(400, 0.5, 'sawtooth', 0.2);
                setTimeout(() => {
                    this.playTone(300, 0.5, 'sawtooth', 0.2);
                }, 100);
            }
            
            // Progress sound - Ascending gentle tones
            createProgressSound() {
                if (!this.canPlayAudio()) return;
                
                const frequency = 600 + Math.random() * 200; // Slight variation
                this.playTone(frequency, 0.3, 'sine', 0.1);
            }
            
            // Deposit complete sound - Celebratory sequence
            createDepositCompleteSound() {
                if (!this.canPlayAudio()) return;
                
                const celebration = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                celebration.forEach((freq, index) => {
                    setTimeout(() => {
                        this.playTone(freq, 0.5, 'sine', 0.2);
                    }, index * 100);
                });
            }
            
            // Confirmation sound - Gentle chime
            createConfirmationSound() {
                if (!this.canPlayAudio()) return;
                
                this.playTone(1000, 0.4, 'sine', 0.1);
                setTimeout(() => {
                    this.playTone(1200, 0.4, 'sine', 0.1);
                }, 80);
            }
            
            // Connection sound - Simple beep
            createConnectionSound() {
                if (!this.canPlayAudio()) return;
                
                this.playTone(800, 0.2, 'sine', 0.05);
            }
            
            // Helper method to play a single tone
            playTone(frequency, volume, waveType = 'sine', duration = 0.2) {
                if (!this.canPlayAudio()) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = waveType;
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    const adjustedVolume = volume * this.volume;
                    gainNode.gain.setValueAtTime(adjustedVolume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.warn('⚠️ Error playing notification sound:', error);
                }
            }
            
            // Helper method to play a chord (multiple notes simultaneously)
            playChord(frequencies, volume, waveType = 'sine', duration = 0.4) {
                if (!this.canPlayAudio()) return;
                
                frequencies.forEach(frequency => {
                    this.playTone(frequency, volume / frequencies.length, waveType, duration);
                });
            }
            
            // Play sound by notification type
            playNotificationSound(type) {
                if (!this.enabled || !this.isInitialized) return;
                
                const soundFunction = this.sounds.get(type);
                if (soundFunction) {
                    try {
                        soundFunction();
                        console.log(`🔊 Playing ${type} notification sound`);
                    } catch (error) {
                        console.warn(`⚠️ Failed to play ${type} sound:`, error);
                    }
                } else {
                    // Fallback to generic info sound
                    this.createInfoSound();
                    console.log(`🔊 Playing fallback sound for ${type}`);
                }
            }
            
            // Check if audio can be played
            canPlayAudio() {
                return this.enabled && this.isInitialized && this.audioContext && this.audioContext.state !== 'suspended';
            }
            
            // Resume audio context if suspended (required by browser policies)
            async resumeAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        console.log('🔊 Audio context resumed');
                    } catch (error) {
                        console.warn('⚠️ Failed to resume audio context:', error);
                    }
                }
            }
            
            // Set volume (0.0 to 1.0)
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                console.log(`🔊 Notification volume set to ${(this.volume * 100).toFixed(0)}%`);
            }
            
            // Enable/disable sounds
            setEnabled(enabled) {
                this.enabled = enabled;
                console.log(`🔊 Notification sounds ${enabled ? 'enabled' : 'disabled'}`);
            }
            
            // Test all sounds
            testAllSounds() {
                if (!this.canPlayAudio()) {
                    console.warn('⚠️ Cannot test sounds - audio not available');
                    return;
                }
                
                const soundTypes = ['info', 'success', 'warning', 'error', 'progress', 'confirmation', 'deposit_complete', 'connection'];
                soundTypes.forEach((type, index) => {
                    setTimeout(() => {
                        console.log(`🧪 Testing ${type} sound...`);
                        this.playNotificationSound(type);
                    }, index * 800); // Space out the tests
                });
            }
        }

        // Advanced Wallet Panel Manager
        class AdvancedWalletPanel {
            constructor() {
                this.panel = document.getElementById('walletPanel');
                this.isOpen = false;
                this.currentTab = 'balance';
                this.transactionData = [];
                this.depositAddress = null;
                
                // WebSocket notification system
                this.ws = null;
                this.wsConnected = false;
                this.notificationContainer = document.getElementById('notificationContainer');
                this.activeNotifications = new Map();
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                // Notification audio system
                this.audioManager = new NotificationAudioManager();
                
                // User settings
                this.settings = {
                    soundEnabled: true,
                    soundVolume: 0.7,
                    notificationFrequency: 'all', // all, important, none
                    theme: 'dark',
                    autoConnect: true
                };
                this.loadUserSettings();
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setupNotificationSystem();
                this.loadInitialData();
                this.startPeriodicUpdates();
                console.log('✅ Advanced Wallet Panel initialized');
            }
            
            setupEventListeners() {
                // Panel toggle
                const toggleBtn = document.getElementById('walletPanelToggle');
                const closeBtn = document.getElementById('walletPanelClose');
                const backdrop = document.getElementById('walletPanelBackdrop');
                
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => this.togglePanel());
                }
                
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.closePanel());
                }
                
                if (backdrop) {
                    backdrop.addEventListener('click', () => this.closePanel());
                }
                
                // Tab switching
                document.querySelectorAll('.wallet-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
                
                // Wallet actions
                document.querySelectorAll('.wallet-action-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        if (action === 'deposit') this.switchTab('deposit');
                        if (action === 'withdraw') this.switchTab('withdraw');
                    });
                });
                
                // Refresh balance
                const refreshBtn = document.getElementById('refreshBalance');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => this.refreshBalance());
                }
                
                // Copy deposit address
                const copyBtn = document.getElementById('copyDepositAddress');
                if (copyBtn) {
                    copyBtn.addEventListener('click', () => this.copyDepositAddress());
                }
                
                // Amount helper buttons
                document.querySelectorAll('.amount-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const percentage = parseInt(e.target.dataset.amount);
                        this.setWithdrawAmount(percentage);
                    });
                });
                
                // Withdraw form
                const withdrawForm = document.getElementById('withdrawAmount');
                if (withdrawForm) {
                    withdrawForm.addEventListener('input', () => this.updateWithdrawInfo());
                }
                
                const submitWithdraw = document.getElementById('submitWithdraw');
                if (submitWithdraw) {
                    submitWithdraw.addEventListener('click', () => this.submitWithdrawal());
                }
                
                // Transaction filters
                const typeFilter = document.getElementById('transactionType');
                const statusFilter = document.getElementById('transactionStatus');
                
                if (typeFilter) {
                    typeFilter.addEventListener('change', () => this.filterTransactions());
                }
                
                if (statusFilter) {
                    statusFilter.addEventListener('change', () => this.filterTransactions());
                }
                
                // Export transactions
                const exportBtn = document.getElementById('exportTransactions');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => this.exportTransactions());
                }
                
                // Notification system
                const connectNotificationsBtn = document.getElementById('connectNotifications');
                if (connectNotificationsBtn) {
                    connectNotificationsBtn.addEventListener('click', () => this.toggleNotifications());
                }
                
                // Settings button
                const settingsBtn = document.getElementById('walletSettingsBtn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => this.showSettingsPanel());
                }
            }
            
            togglePanel() {
                if (this.isOpen) {
                    this.closePanel();
                } else {
                    this.openPanel();
                }
            }
            
            openPanel() {
                this.panel.classList.add('active');
                this.isOpen = true;
                this.refreshData();
                
                // Auto-connect WebSocket notifications when panel opens
                if (!this.wsConnected) {
                    this.connectWebSocket();
                }
                
                document.body.style.overflow = 'hidden';
                console.log('💰 Wallet panel opened');
                
                // Log audit event
                this.logAuditEvent('wallet_panel_opened', {
                    timestamp: Date.now(),
                    autoConnectWebSocket: !this.wsConnected
                });
            }
            
            closePanel() {
                this.panel.classList.remove('active');
                this.isOpen = false;
                document.body.style.overflow = '';
                console.log('💰 Wallet panel closed');
            }
            
            switchTab(tabName) {
                // Remove active class from all tabs and content
                document.querySelectorAll('.wallet-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                document.querySelectorAll('.wallet-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Add active class to selected tab and content
                const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
                const selectedContent = document.getElementById(`${tabName}-tab`);
                
                if (selectedTab) selectedTab.classList.add('active');
                if (selectedContent) selectedContent.classList.add('active');
                
                this.currentTab = tabName;
                
                // Load tab-specific data
                if (tabName === 'history') {
                    this.loadTransactionHistory();
                } else if (tabName === 'deposit') {
                    this.loadDepositInfo();
                } else if (tabName === 'withdraw') {
                    this.updateWithdrawInfo();
                }
                
                console.log(`💰 Switched to ${tabName} tab`);
            }
            
            loadInitialData() {
                this.updateBalanceDisplay();
                this.generateDepositAddress();
            }
            
            refreshBalance() {
                console.log('🔄 Refreshing wallet balance...');
                
                // Show loading state
                const refreshBtn = document.getElementById('refreshBalance');
                if (refreshBtn) {
                    refreshBtn.textContent = '🔄 Actualizando...';
                    refreshBtn.disabled = true;
                }
                
                // Simulate API call or use existing refresh function
                if (typeof window.refreshBalanceAndDeposits === 'function') {
                    window.refreshBalanceAndDeposits();
                }
                
                // Update display
                setTimeout(() => {
                    this.updateBalanceDisplay();
                    
                    if (refreshBtn) {
                        refreshBtn.textContent = '🔄 Actualizar';
                        refreshBtn.disabled = false;
                    }
                    
                    this.showNotification('Balance actualizado correctamente', 'success');
                }, 1000);
            }
            
            updateBalanceDisplay() {
                const balance = gameState.balance || 0;
                // Update main balance
                const mainBalance = document.getElementById('walletMainBalance');
                
                if (mainBalance) {
                    mainBalance.textContent = this.formatMY(balance);
                }
                
                // Update statistics
                const totalDeposited = document.getElementById('totalDeposited');
                const totalWon = document.getElementById('totalWon');
                const totalWagered = document.getElementById('totalWagered');
                
                if (totalDeposited) {
                    // In demo mode, show demo balance as "deposited"
                    const depositAmount = gameState.demoMode ? 10000000 : (balance + gameState.totalWagered - gameState.totalWon);
                    totalDeposited.textContent = this.formatMY(depositAmount);
                }
                
                if (totalWon) {
                    totalWon.textContent = this.formatMY(gameState.totalWon || 0);
                }
                
                if (totalWagered) {
                    totalWagered.textContent = this.formatMY(gameState.totalWagered || 0);
                }
            }
            
            async generateDepositAddress() {
                try {
                    // Si estamos en modo demo, generar dirección simulada
                    if (gameState.demoMode) {
                        this.depositAddress = 'bc1q' + this.generateRandomString(42);
                        const addressInput = document.getElementById('depositAddress');
                        if (addressInput) {
                            addressInput.value = this.depositAddress;
                        }
                        this.generateQRCode();
                        return;
                    }
                    
                    // Obtener dirección real desde el backend
                    const response = await fetch('/api/transactions/deposits/generate-address', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.depositAddress = data.depositAddress;
                        const addressInput = document.getElementById('depositAddress');
                        if (addressInput) {
                            addressInput.value = this.depositAddress;
                        }
                        this.generateQRCode();
                        console.log('✅ Deposit address generated:', this.depositAddress);
                    } else {
                        console.warn('Error generating deposit address:', data.error);
                        // Fallback a dirección demo
                        this.depositAddress = gameState.walletAddress || ('bc1q' + this.generateRandomString(42));
                        const addressInput = document.getElementById('depositAddress');
                        if (addressInput) {
                            addressInput.value = this.depositAddress;
                        }
                        this.generateQRCode();
                    }
                } catch (error) {
                    console.error('Error generating deposit address:', error);
                    // Fallback a dirección demo
                    this.depositAddress = gameState.walletAddress || ('bc1q' + this.generateRandomString(42));
                    const addressInput = document.getElementById('depositAddress');
                    if (addressInput) {
                        addressInput.value = this.depositAddress;
                    }
                    this.generateQRCode();
                }
            }
            
            generateQRCode() {
                const qrContainer = document.getElementById('depositQR');
                if (qrContainer && this.depositAddress) {
                    qrContainer.innerHTML = `
                        <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                            <div style="width: 150px; height: 150px; margin: 0 auto; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #666;">
                                QR Code<br/>
                                (${this.depositAddress.substring(0, 8)}...)
                            </div>
                        </div>
                    `;
                }
            }
            
            copyDepositAddress() {
                if (this.depositAddress) {
                    navigator.clipboard.writeText(this.depositAddress).then(() => {
                        this.showNotification('Dirección copiada al portapapeles', 'success');
                        
                        const copyBtn = document.getElementById('copyDepositAddress');
                        if (copyBtn) {
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = '✓';
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                            }, 2000);
                        }
                    }).catch(() => {
                        this.showNotification('Error al copiar dirección', 'error');
                    });
                }
            }
            
            async loadTransactionHistory() {
                try {
                    // Si estamos en modo demo, usar datos simulados
                    if (gameState.demoMode) {
                        this.transactionData = this.generateDemoTransactions();
                        this.renderTransactionTable();
                        return;
                    }
                    
                    // Cargar historial real desde el backend
                    const response = await fetch('/api/transactions/history?limit=50');
                    const data = await response.json();
                    
                    if (data.success) {
                        this.transactionData = data.history.map(tx => ({
                            id: tx.id,
                            date: tx.timestamp,
                            type: tx.type,
                            amount: tx.amount,
                            status: tx.status,
                            hash: tx.txid || tx.id,
                            confirmations: tx.confirmations,
                            fee: tx.fee
                        }));
                        this.renderTransactionTable();
                        console.log(`✅ Loaded ${this.transactionData.length} transactions from backend`);
                    } else {
                        console.warn('Error loading transaction history:', data.error);
                        // Fallback to demo data
                        this.transactionData = this.generateDemoTransactions();
                        this.renderTransactionTable();
                    }
                } catch (error) {
                    console.error('Error loading transaction history:', error);
                    // Fallback to demo data
                    this.transactionData = this.generateDemoTransactions();
                    this.renderTransactionTable();
                }
            }
            
            generateDemoTransactions() {
                const transactions = [];
                const types = ['deposit', 'withdraw', 'bet', 'win'];
                const statuses = ['confirmed', 'pending', 'failed'];
                
                for (let i = 0; i < 15; i++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    const status = i < 2 ? 'pending' : 'confirmed'; // First 2 are pending
                    const amount = Math.floor(Math.random() * 1000000) + 10000;
                    const date = new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000);
                    
                    transactions.push({
                        id: `tx_${i + 1}`,
                        date: date.toISOString(),
                        type: type,
                        amount: amount,
                        status: status,
                        hash: this.generateRandomString(64),
                        timestamp: date.getTime()
                    });
                }
                
                return transactions.sort((a, b) => b.timestamp - a.timestamp);
            }
            
            renderTransactionTable() {
                const tableBody = document.getElementById('transactionTableBody');
                if (!tableBody) return;
                
                if (this.transactionData.length === 0) {
                    tableBody.innerHTML = `
                        <tr class="no-transactions">
                            <td colspan="6">No hay transacciones disponibles</td>
                        </tr>
                    `;
                    return;
                }
                
                const html = this.transactionData.map(tx => `
                    <tr>
                        <td>${new Date(tx.date).toLocaleDateString()}</td>
                        <td>
                            <span class="tx-type tx-type-${tx.type}">
                                ${this.getTypeIcon(tx.type)} ${this.getTypeLabel(tx.type)}
                            </span>
                        </td>
                        <td class="${tx.type === 'withdraw' || tx.type === 'bet' ? 'negative' : 'positive'}">
                            ${tx.type === 'withdraw' || tx.type === 'bet' ? '-' : '+'}${this.formatMY(tx.amount)}
                        </td>
                        <td>
                            <span class="tx-status tx-status-${tx.status}">
                                ${this.getStatusIcon(tx.status)} ${this.getStatusLabel(tx.status)}
                            </span>
                        </td>
                        <td>
                            <code style="font-size: 0.8rem; color: #888;">
                                ${tx.hash.substring(0, 8)}...${tx.hash.substring(-8)}
                            </code>
                        </td>
                        <td>
                            <button class="tx-action-btn" onclick="walletPanel.viewTransaction('${tx.id}')">
                                👁️ Ver
                            </button>
                        </td>
                    </tr>
                `).join('');
                
                tableBody.innerHTML = html;
            }
            
            filterTransactions() {
                const typeFilter = document.getElementById('transactionType').value;
                const statusFilter = document.getElementById('transactionStatus').value;
                
                let filteredData = [...this.transactionData];
                
                if (typeFilter !== 'all') {
                    filteredData = filteredData.filter(tx => tx.type === typeFilter);
                }
                
                if (statusFilter !== 'all') {
                    filteredData = filteredData.filter(tx => tx.status === statusFilter);
                }
                
                // Temporarily replace transaction data for rendering
                const originalData = this.transactionData;
                this.transactionData = filteredData;
                this.renderTransactionTable();
                this.transactionData = originalData;
            }
            
            loadDepositInfo() {
                // Load pending deposits
                this.loadPendingDeposits();
            }
            
            loadPendingDeposits() {
                const pendingList = document.getElementById('pendingDepositsList');
                if (!pendingList) return;
                
                // Demo pending deposits
                const pendingDeposits = [
                    {
                        amount: 50000,
                        confirmations: 0,
                        required: 1,
                        hash: this.generateRandomString(64)
                    }
                ];
                
                if (pendingDeposits.length === 0) {
                    pendingList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No hay depósitos pendientes</p>';
                } else {
                    const html = pendingDeposits.map(deposit => `
                        <div class="pending-deposit-item">
                            <div class="pending-amount">${this.formatMY(deposit.amount)}</div>
                            <div class="pending-status">
                                ${deposit.confirmations}/${deposit.required} confirmaciones
                            </div>
                            <div class="pending-hash">
                                ${deposit.hash.substring(0, 8)}...${deposit.hash.substring(-8)}
                            </div>
                        </div>
                    `).join('');
                    
                    pendingList.innerHTML = html;
                }
            }
            
            setWithdrawAmount(percentage) {
                const balance = gameState.balance || 0;
                const amount = Math.floor((balance * percentage) / 100);
                
                const withdrawInput = document.getElementById('withdrawAmount');
                if (withdrawInput) {
                    withdrawInput.value = amount;
                    this.updateWithdrawInfo();
                }
            }
            
            updateWithdrawInfo() {
                const withdrawInput = document.getElementById('withdrawAmount');
                const amount = parseInt(withdrawInput?.value || 0);
                const fee = 1000; // Fixed fee
                const total = Math.max(0, amount - fee);
                
                const amountDisplay = document.getElementById('withdrawAmountDisplay');
                const feeDisplay = document.getElementById('withdrawFee');
                const totalDisplay = document.getElementById('withdrawTotal');
                const submitBtn = document.getElementById('submitWithdraw');
                
                if (amountDisplay) amountDisplay.textContent = this.formatMY(amount);
                if (feeDisplay) feeDisplay.textContent = this.formatMY(fee);
                if (totalDisplay) totalDisplay.textContent = this.formatMY(total);
                
                // Validate withdraw button
                const isValid = amount >= 1000 && amount <= (gameState.balance || 0);
                if (submitBtn) {
                    submitBtn.disabled = !isValid;
                    submitBtn.textContent = isValid ? '⬆️ Retirar MOONYETIS' : 
                        amount < 1000 ? 'Mínimo 1,000 MY' : 
                        amount > (gameState.balance || 0) ? 'Saldo insuficiente' : '⬆️ Retirar MOONYETIS';
                }
            }
            
            submitWithdrawal() {
                const addressInput = document.getElementById('withdrawAddress');
                const amountInput = document.getElementById('withdrawAmount');
                
                const address = addressInput?.value?.trim();
                const amount = parseInt(amountInput?.value || 0);
                
                if (!address || !amount) {
                    this.showNotification('Complete todos los campos', 'error');
                    return;
                }
                
                if (amount < 1000) {
                    this.showNotification('Monto mínimo: 1,000 MY', 'error');
                    return;
                }
                
                if (amount > (gameState.balance || 0)) {
                    this.showNotification('Saldo insuficiente', 'error');
                    return;
                }
                
                // Show confirmation
                if (confirm(`¿Confirmar retiro de ${this.formatMY(amount)} a ${address}?`)) {
                    this.processWithdrawal(address, amount);
                }
            }
            
            async processWithdrawal(address, amount) {
                console.log(`💸 Processing withdrawal: ${amount} MY to ${address}`);
                
                const submitBtn = document.getElementById('submitWithdraw');
                if (submitBtn) {
                    submitBtn.textContent = '⏳ Procesando...';
                    submitBtn.disabled = true;
                }
                
                try {
                    // Si estamos en modo demo, simular el retiro
                    if (gameState.demoMode) {
                        setTimeout(() => {
                            // Update balance
                            gameState.balance = Math.max(0, (gameState.balance || 0) - amount - 1000); // amount + fee
                            
                            // Reset form
                            document.getElementById('withdrawAddress').value = '';
                            document.getElementById('withdrawAmount').value = '';
                            
                            // Update UI
                            this.updateBalanceDisplay();
                            this.updateWithdrawInfo();
                            
                            // Show success
                            this.showNotification(`Retiro demo de ${this.formatMY(amount)} enviado exitosamente`, 'success');
                            
                            // Reset button
                            if (submitBtn) {
                                submitBtn.textContent = '⬆️ Retirar MOONYETIS';
                                submitBtn.disabled = false;
                            }
                            
                            // Switch to history tab and refresh
                            this.switchTab('history');
                        }, 2000);
                        return;
                    }
                    
                    // Procesar retiro real con el backend
                    const response = await fetch('/api/transactions/withdrawals/submit', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            toAddress: address,
                            amount: amount,
                            fee: 1000
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Update balance
                        gameState.balance = Math.max(0, (gameState.balance || 0) - data.withdrawal.total);
                        
                        // Reset form
                        document.getElementById('withdrawAddress').value = '';
                        document.getElementById('withdrawAmount').value = '';
                        
                        // Update UI
                        this.updateBalanceDisplay();
                        this.updateWithdrawInfo();
                        
                        // Show success
                        this.showNotification(`Retiro de ${this.formatMY(amount)} enviado exitosamente`, 'success');
                        console.log('✅ Withdrawal submitted:', data.withdrawal);
                        
                        // Reset button
                        if (submitBtn) {
                            submitBtn.textContent = '⬆️ Retirar MOONYETIS';
                            submitBtn.disabled = false;
                        }
                        
                        // Switch to history tab and refresh
                        this.switchTab('history');
                    } else {
                        this.showNotification(`Error: ${data.error}`, 'error');
                        // Reset button
                        if (submitBtn) {
                            submitBtn.textContent = '⬆️ Retirar MOONYETIS';
                            submitBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.error('Error processing withdrawal:', error);
                    this.showNotification('Error procesando retiro. Intenta de nuevo.', 'error');
                    // Reset button
                    if (submitBtn) {
                        submitBtn.textContent = '⬆️ Retirar MOONYETIS';
                        submitBtn.disabled = false;
                    }
                }
            }
            
            async exportTransactions() {
                console.log('📄 Exporting transactions...');
                
                try {
                    // Si estamos en modo demo, usar datos locales
                    if (gameState.demoMode) {
                        const csv = this.transactionsToCsv();
                        const blob = new Blob([csv], { type: 'text/csv' });
                        const url = window.URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `moonyetis_transactions_demo_${new Date().toISOString().split('T')[0]}.csv`;
                        a.click();
                        
                        window.URL.revokeObjectURL(url);
                        this.showNotification('Transacciones demo exportadas', 'success');
                        return;
                    }
                    
                    // Exportar desde el backend
                    const response = await fetch('/api/transactions/history/export?format=csv');
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `moonyetis_transactions_${new Date().toISOString().split('T')[0]}.csv`;
                        a.click();
                        
                        window.URL.revokeObjectURL(url);
                        this.showNotification('Transacciones exportadas', 'success');
                        console.log('✅ Transactions exported from backend');
                    } else {
                        throw new Error('Error en la respuesta del servidor');
                    }
                } catch (error) {
                    console.error('Error exporting transactions:', error);
                    // Fallback a exportación local
                    const csv = this.transactionsToCsv();
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = window.URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `moonyetis_transactions_backup_${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                    
                    window.URL.revokeObjectURL(url);
                    this.showNotification('Transacciones exportadas (modo local)', 'success');
                }
            }
            
            transactionsToCsv() {
                const headers = ['Fecha', 'Tipo', 'Cantidad', 'Estado', 'Hash'];
                const rows = this.transactionData.map(tx => [
                    new Date(tx.date).toLocaleDateString(),
                    this.getTypeLabel(tx.type),
                    tx.amount,
                    this.getStatusLabel(tx.status),
                    tx.hash
                ]);
                
                const csv = [headers, ...rows]
                    .map(row => row.map(field => `"${field}"`).join(','))
                    .join('\n');
                
                return csv;
            }
            
            viewTransaction(txId) {
                const tx = this.transactionData.find(t => t.id === txId);
                if (tx) {
                    alert(`
                        Transacción: ${tx.id}
                        Fecha: ${new Date(tx.date).toLocaleString()}
                        Tipo: ${this.getTypeLabel(tx.type)}
                        Cantidad: ${this.formatMY(tx.amount)}
                        Estado: ${this.getStatusLabel(tx.status)}
                        Hash: ${tx.hash}
                    `);
                }
            }
            
            refreshData() {
                this.updateBalanceDisplay();
                if (this.currentTab === 'history') {
                    this.loadTransactionHistory();
                } else if (this.currentTab === 'deposit') {
                    this.loadDepositInfo();
                }
            }
            
            startPeriodicUpdates() {
                // Update balance every 30 seconds when panel is open
                setInterval(() => {
                    if (this.isOpen) {
                        this.updateBalanceDisplay();
                    }
                }, 30000);
            }
            
            showNotification(message, type = 'info') {
                // Use existing notification system or create temporary one
                if (window.slotMachine && window.slotMachine.showMessage) {
                    const messageType = type === 'success' ? 'win' : type === 'error' ? 'lose' : 'neutral';
                    window.slotMachine.showMessage(message, messageType);
                } else {
                    console.log(`${type.toUpperCase()}: ${message}`);
                }
            }
            
            // Utility functions
            formatMY(amount) {
                if (amount >= 1000000) {
                    return (amount / 1000000).toFixed(1) + 'M MY';
                } else if (amount >= 1000) {
                    return (amount / 1000).toFixed(0) + 'K MY';
                } else {
                    return amount.toLocaleString() + ' MY';
                }
            }
            
            generateRandomString(length) {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
            
            getTypeIcon(type) {
                const icons = {
                    deposit: '⬇️',
                    withdraw: '⬆️',
                    bet: '🎰',
                    win: '🏆'
                };
                return icons[type] || '📄';
            }
            
            getTypeLabel(type) {
                const labels = {
                    deposit: 'Depósito',
                    withdraw: 'Retiro',
                    bet: 'Apuesta',
                    win: 'Ganancia'
                };
                return labels[type] || type;
            }
            
            getStatusIcon(status) {
                const icons = {
                    confirmed: '✅',
                    pending: '⏳',
                    failed: '❌'
                };
                return icons[status] || '❓';
            }
            
            // === NOTIFICATION SYSTEM METHODS ===
            
            setupNotificationSystem() {
                console.log('📢 Setting up notification system...');
                this.updateConnectionStatus('offline', 'Desconectado');
            }
            
            connectWebSocket() {
                try {
                    const wsUrl = `ws://${window.location.host}/ws`;
                    console.log(`📢 Connecting to WebSocket: ${wsUrl}`);
                    
                    this.logAuditEvent('websocket_connect_attempt', {
                        url: wsUrl,
                        timestamp: Date.now()
                    });
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('✅ WebSocket connected');
                        this.wsConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateConnectionStatus('connected', 'Conectado');
                        
                        // Play connection sound
                        this.audioManager.playNotificationSound('connection');
                        
                        // Log successful connection
                        this.logAuditEvent('websocket_connected', {
                            timestamp: Date.now(),
                            reconnectAttempts: this.reconnectAttempts
                        });
                        
                        this.authenticateWebSocket();
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('❌ Error parsing WebSocket message:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('🔌 WebSocket disconnected');
                        this.wsConnected = false;
                        this.updateConnectionStatus('offline', 'Desconectado');
                        this.scheduleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('❌ WebSocket error:', error);
                        this.updateConnectionStatus('error', 'Error de conexión');
                    };
                    
                } catch (error) {
                    console.error('❌ Failed to connect WebSocket:', error);
                    this.updateConnectionStatus('error', 'Error de conexión');
                }
            }
            
            authenticateWebSocket() {
                const demoAddress = 'bc1qdemotestaddress';
                const authMessage = {
                    type: 'authenticate',
                    walletAddress: demoAddress,
                    signature: 'demo_signature',
                    timestamp: Date.now()
                };
                
                this.ws.send(JSON.stringify(authMessage));
                console.log('🔐 Authentication sent');
                
                // Subscribe to channels
                setTimeout(() => {
                    const subscribeMessage = {
                        type: 'subscribe',
                        channels: ['deposits', 'balance', 'general']
                    };
                    
                    this.ws.send(JSON.stringify(subscribeMessage));
                    console.log('📺 Subscribed to notification channels');
                }, 1000);
            }
            
            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                    
                    console.log(`🔄 Scheduling reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`);
                    this.updateConnectionStatus('reconnecting', `Reconectando... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    
                    setTimeout(() => {
                        if (!this.wsConnected) {
                            this.connectWebSocket();
                        }
                    }, delay);
                } else {
                    console.log('❌ Max reconnect attempts reached');
                    this.updateConnectionStatus('failed', 'Conexión fallida');
                }
            }
            
            handleWebSocketMessage(data) {
                console.log('📨 WebSocket message received:', data);
                
                switch (data.type) {
                    case 'confirmation_progress':
                        this.handleConfirmationProgress(data);
                        break;
                    case 'deposit_completed':
                        this.handleDepositCompleted(data);
                        break;
                    case 'balance_update':
                        this.handleBalanceUpdate(data);
                        break;
                    case 'test_notification':
                        this.showNotification('🧪 Test', data.data.message, 'info');
                        break;
                    case 'auth_success':
                        console.log('✅ WebSocket authentication successful');
                        break;
                    case 'auth_error':
                        console.error('❌ WebSocket authentication failed:', data.message);
                        break;
                    default:
                        console.log('📨 Unknown message type:', data.type);
                }
            }
            
            handleConfirmationProgress(data) {
                const { confirmations, status, message, txid, amount } = data;
                const progressText = `${confirmations.current}/${confirmations.required}`;
                
                // Play confirmation sound
                this.audioManager.playNotificationSound('confirmation');
                
                // Show toast notification
                this.showNotification(
                    `📈 Confirmación ${progressText}`,
                    message,
                    this.getStatusType(status),
                    true,
                    txid
                );
                
                // Update pending deposits UI
                this.updatePendingDepositProgress(data);
            }
            
            handleDepositCompleted(data) {
                const { amount, totalChips, txid } = data;
                
                // Play celebratory deposit complete sound
                this.audioManager.playNotificationSound('deposit_complete');
                
                this.showNotification(
                    '✅ Depósito Completado',
                    `${totalChips} chips agregados a tu balance`,
                    'success',
                    false
                );
                
                // Refresh balance and transaction history
                this.refreshBalance();
                this.loadTransactionHistory();
            }
            
            handleBalanceUpdate(data) {
                const { newBalance, depositAmount } = data;
                
                // Update balance display
                const balanceElement = document.getElementById('walletMainBalance');
                if (balanceElement) {
                    balanceElement.textContent = `${newBalance.toLocaleString()} MY`;
                    
                    // Add animation effect
                    balanceElement.style.animation = 'none';
                    setTimeout(() => {
                        balanceElement.style.animation = 'balanceUpdate 0.6s ease-out';
                    }, 10);
                }
            }
            
            showNotification(title, message, type = 'info', persistent = false, id = null) {
                const notificationId = id || Date.now().toString();
                
                // Remove existing notification with same ID
                if (this.activeNotifications.has(notificationId)) {
                    this.removeNotification(notificationId);
                }
                
                // Play appropriate sound for notification type
                if (this.settings.soundEnabled) {
                    this.audioManager.playNotificationSound(type);
                }
                
                const notification = document.createElement('div');
                notification.className = `notification-toast ${type}`;
                notification.dataset.id = notificationId;
                
                const iconMap = {
                    success: '✅',
                    info: 'ℹ️',
                    warning: '⚠️',
                    error: '❌',
                    progress: '📈'
                };
                
                notification.innerHTML = `
                    <div class="notification-icon">${iconMap[type] || 'ℹ️'}</div>
                    <div class="notification-content">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                        <div class="notification-time">${new Date().toLocaleTimeString()}</div>
                    </div>
                    <button class="notification-close" onclick="walletPanel.removeNotification('${notificationId}')">&times;</button>
                `;
                
                // Add progress bar for progress notifications
                if (type === 'progress' && id) {
                    const progressData = this.getProgressData(id);
                    if (progressData) {
                        const progressBar = document.createElement('div');
                        progressBar.className = 'notification-progress';
                        progressBar.innerHTML = `
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progressData.percentage}%"></div>
                            </div>
                        `;
                        notification.appendChild(progressBar);
                    }
                }
                
                this.notificationContainer.appendChild(notification);
                this.activeNotifications.set(notificationId, notification);
                
                // Auto-remove after delay (unless persistent)
                if (!persistent) {
                    setTimeout(() => {
                        this.removeNotification(notificationId);
                    }, type === 'error' ? 8000 : 5000);
                }
                
                console.log(`📢 Notification shown: ${title}`);
            }
            
            removeNotification(notificationId) {
                const notification = this.activeNotifications.get(notificationId);
                if (notification && notification.parentNode) {
                    notification.style.animation = 'slideOutToRight 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                        this.activeNotifications.delete(notificationId);
                    }, 300);
                }
            }
            
            updateConnectionStatus(status, text) {
                const statusDot = document.querySelector('#wsConnectionStatus .status-dot');
                const statusText = document.querySelector('#wsConnectionStatus .status-text');
                const connectBtn = document.getElementById('connectNotifications');
                
                if (statusDot) {
                    statusDot.className = `status-dot ${status}`;
                }
                
                if (statusText) {
                    statusText.textContent = text;
                }
                
                if (connectBtn) {
                    if (status === 'connected') {
                        connectBtn.textContent = '📢 Notificaciones Activas';
                        connectBtn.disabled = false;
                    } else if (status === 'reconnecting') {
                        connectBtn.textContent = '🔄 Reconectando...';
                        connectBtn.disabled = true;
                    } else {
                        connectBtn.textContent = '📢 Activar Notificaciones';
                        connectBtn.disabled = false;
                    }
                }
            }
            
            toggleNotifications() {
                if (this.wsConnected) {
                    this.disconnectWebSocket();
                } else {
                    this.connectWebSocket();
                }
            }
            
            disconnectWebSocket() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                    this.wsConnected = false;
                    this.updateConnectionStatus('offline', 'Desconectado');
                }
            }
            
            getStatusType(status) {
                const statusTypes = {
                    'confirmed': 'success',
                    'nearly_confirmed': 'progress',
                    'half_confirmed': 'progress',
                    'first_confirmation': 'info',
                    'unconfirmed': 'warning',
                    'pending': 'info',
                    'failed': 'error'
                };
                return statusTypes[status] || 'info';
            }
            
            updatePendingDepositProgress(data) {
                const pendingList = document.getElementById('pendingDepositsList');
                if (!pendingList) return;
                
                let depositElement = pendingList.querySelector(`[data-txid="${data.txid}"]`);
                
                if (!depositElement) {
                    // Create new pending deposit element
                    depositElement = document.createElement('div');
                    depositElement.className = 'pending-deposit-item';
                    depositElement.dataset.txid = data.txid;
                    pendingList.appendChild(depositElement);
                }
                
                const { confirmations, status, amount } = data;
                const progressPercentage = confirmations.percentage;
                
                depositElement.innerHTML = `
                    <div class="deposit-header">
                        <span class="deposit-amount">${amount.toLocaleString()} MY</span>
                        <span class="deposit-status ${status}">${this.getStatusLabel(status)}</span>
                    </div>
                    <div class="confirmation-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                        </div>
                        <span class="progress-text">${confirmations.current}/${confirmations.required} confirmaciones</span>
                    </div>
                    <div class="deposit-txid">
                        <small>TXID: ${data.txid.substring(0, 16)}...</small>
                    </div>
                `;
                
                // Remove when confirmed
                if (status === 'confirmed') {
                    setTimeout(() => {
                        if (depositElement.parentNode) {
                            depositElement.parentNode.removeChild(depositElement);
                        }
                    }, 3000);
                }
            }
            
            getStatusLabel(status) {
                const labels = {
                    confirmed: 'Confirmado',
                    pending: 'Pendiente',
                    failed: 'Fallido',
                    nearly_confirmed: 'Casi Confirmado',
                    half_confirmed: 'Medio Confirmado',
                    first_confirmation: 'Primera Confirmación',
                    unconfirmed: 'Sin Confirmar'
                };
                return labels[status] || status;
            }
            
            // === USER SETTINGS METHODS ===
            
            loadUserSettings() {
                try {
                    const savedSettings = localStorage.getItem('moonyetis_wallet_settings');
                    if (savedSettings) {
                        const parsed = JSON.parse(savedSettings);
                        this.settings = { ...this.settings, ...parsed };
                        console.log('⚙️ User settings loaded:', this.settings);
                    }
                    
                    // Apply loaded settings
                    this.applySettings();
                } catch (error) {
                    console.warn('⚠️ Failed to load user settings:', error);
                }
            }
            
            saveUserSettings() {
                try {
                    localStorage.setItem('moonyetis_wallet_settings', JSON.stringify(this.settings));
                    console.log('💾 User settings saved');
                } catch (error) {
                    console.warn('⚠️ Failed to save user settings:', error);
                }
            }
            
            applySettings() {
                // Apply audio settings
                if (this.audioManager) {
                    this.audioManager.setEnabled(this.settings.soundEnabled);
                    this.audioManager.setVolume(this.settings.soundVolume);
                }
                
                // Apply theme settings
                if (this.settings.theme) {
                    document.documentElement.setAttribute('data-theme', this.settings.theme);
                }
                
                console.log('⚙️ Settings applied:', this.settings);
            }
            
            updateSetting(key, value) {
                this.settings[key] = value;
                this.applySettings();
                this.saveUserSettings();
                
                // Log setting change for audit
                this.logAuditEvent('setting_changed', {
                    setting: key,
                    newValue: value,
                    timestamp: Date.now()
                });
            }
            
            // === AUDIT LOGGING METHODS ===
            
            logAuditEvent(eventType, data) {
                const auditEvent = {
                    id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    type: eventType,
                    timestamp: new Date().toISOString(),
                    data: data,
                    sessionId: this.getSessionId(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                try {
                    // Store locally for debugging
                    const auditLogs = JSON.parse(localStorage.getItem('moonyetis_audit_logs') || '[]');
                    auditLogs.push(auditEvent);
                    
                    // Keep only last 1000 entries
                    if (auditLogs.length > 1000) {
                        auditLogs.splice(0, auditLogs.length - 1000);
                    }
                    
                    localStorage.setItem('moonyetis_audit_logs', JSON.stringify(auditLogs));
                    
                    // Send to backend if available
                    this.sendAuditLog(auditEvent);
                    
                    console.log(`📝 Audit log: ${eventType}`, data);
                } catch (error) {
                    console.warn('⚠️ Failed to log audit event:', error);
                }
            }
            
            async sendAuditLog(auditEvent) {
                try {
                    await fetch('/api/audit/log', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(auditEvent)
                    });
                } catch (error) {
                    console.warn('⚠️ Failed to send audit log to backend:', error);
                }
            }
            
            getSessionId() {
                let sessionId = localStorage.getItem('moonyetis_session_id');
                if (!sessionId) {
                    sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('moonyetis_session_id', sessionId);
                }
                return sessionId;
            }
            
            getAuditLogs(limit = 100) {
                try {
                    const auditLogs = JSON.parse(localStorage.getItem('moonyetis_audit_logs') || '[]');
                    return auditLogs.slice(-limit).reverse(); // Get latest logs first
                } catch (error) {
                    console.warn('⚠️ Failed to get audit logs:', error);
                    return [];
                }
            }
            
            clearAuditLogs() {
                localStorage.removeItem('moonyetis_audit_logs');
                this.logAuditEvent('audit_logs_cleared', { clearedAt: Date.now() });
            }
            
            // === SETTINGS UI METHODS ===
            
            showSettingsPanel() {
                const settingsHTML = `
                    <div class="settings-modal">
                        <div class="settings-modal-content">
                            <div class="settings-header">
                                <h3>⚙️ Configuraciones</h3>
                                <button class="settings-close" onclick="walletPanel.hideSettingsPanel()">&times;</button>
                            </div>
                            
                            <div class="settings-body">
                                <div class="setting-group">
                                    <h4>🔊 Audio</h4>
                                    
                                    <div class="setting-item">
                                        <label>
                                            <input type="checkbox" id="soundEnabled" ${this.settings.soundEnabled ? 'checked' : ''}>
                                            Activar sonidos de notificación
                                        </label>
                                    </div>
                                    
                                    <div class="setting-item">
                                        <label>Volumen de notificaciones</label>
                                        <input type="range" id="soundVolume" min="0" max="1" step="0.1" value="${this.settings.soundVolume}">
                                        <span id="volumeDisplay">${Math.round(this.settings.soundVolume * 100)}%</span>
                                    </div>
                                    
                                    <div class="setting-item">
                                        <button class="test-sounds-btn" onclick="walletPanel.audioManager.testAllSounds()">
                                            🧪 Probar Sonidos
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="setting-group">
                                    <h4>📢 Notificaciones</h4>
                                    
                                    <div class="setting-item">
                                        <label>Frecuencia de notificaciones</label>
                                        <select id="notificationFrequency">
                                            <option value="all" ${this.settings.notificationFrequency === 'all' ? 'selected' : ''}>Todas</option>
                                            <option value="important" ${this.settings.notificationFrequency === 'important' ? 'selected' : ''}>Solo importantes</option>
                                            <option value="none" ${this.settings.notificationFrequency === 'none' ? 'selected' : ''}>Ninguna</option>
                                        </select>
                                    </div>
                                    
                                    <div class="setting-item">
                                        <label>
                                            <input type="checkbox" id="autoConnect" ${this.settings.autoConnect ? 'checked' : ''}>
                                            Conectar automáticamente al abrir
                                        </label>
                                    </div>
                                </div>
                                
                                <div class="setting-group">
                                    <h4>🎨 Apariencia</h4>
                                    
                                    <div class="setting-item">
                                        <label>Tema</label>
                                        <select id="theme">
                                            <option value="dark" ${this.settings.theme === 'dark' ? 'selected' : ''}>Oscuro</option>
                                            <option value="light" ${this.settings.theme === 'light' ? 'selected' : ''}>Claro</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="setting-group">
                                    <h4>🔧 Debug</h4>
                                    
                                    <div class="setting-item">
                                        <button class="debug-btn" onclick="walletPanel.showAuditLogs()">
                                            📝 Ver Logs de Auditoría
                                        </button>
                                        <button class="debug-btn" onclick="walletPanel.clearAuditLogs()">
                                            🗑️ Limpiar Logs
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-footer">
                                <button class="settings-save-btn" onclick="walletPanel.saveSettings()">
                                    💾 Guardar Configuración
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Remove existing settings panel
                const existing = document.querySelector('.settings-modal');
                if (existing) {
                    existing.remove();
                }
                
                // Add new settings panel
                document.body.insertAdjacentHTML('beforeend', settingsHTML);
                
                this.setupSettingsEventListeners();
                this.logAuditEvent('settings_panel_opened', {});
            }
            
            hideSettingsPanel() {
                const settingsPanel = document.querySelector('.settings-modal');
                if (settingsPanel) {
                    settingsPanel.remove();
                }
                this.logAuditEvent('settings_panel_closed', {});
            }
            
            setupSettingsEventListeners() {
                // Volume slider real-time update
                const volumeSlider = document.getElementById('soundVolume');
                const volumeDisplay = document.getElementById('volumeDisplay');
                
                if (volumeSlider && volumeDisplay) {
                    volumeSlider.addEventListener('input', (e) => {
                        const volume = parseFloat(e.target.value);
                        volumeDisplay.textContent = Math.round(volume * 100) + '%';
                        this.audioManager.setVolume(volume);
                    });
                }
            }
            
            saveSettings() {
                // Collect all settings from UI
                const soundEnabled = document.getElementById('soundEnabled')?.checked ?? this.settings.soundEnabled;
                const soundVolume = parseFloat(document.getElementById('soundVolume')?.value ?? this.settings.soundVolume);
                const notificationFrequency = document.getElementById('notificationFrequency')?.value ?? this.settings.notificationFrequency;
                const autoConnect = document.getElementById('autoConnect')?.checked ?? this.settings.autoConnect;
                const theme = document.getElementById('theme')?.value ?? this.settings.theme;
                
                // Update settings
                this.updateSetting('soundEnabled', soundEnabled);
                this.updateSetting('soundVolume', soundVolume);
                this.updateSetting('notificationFrequency', notificationFrequency);
                this.updateSetting('autoConnect', autoConnect);
                this.updateSetting('theme', theme);
                
                // Show confirmation
                this.showNotification('⚙️ Configuración guardada', 'Tus preferencias han sido guardadas correctamente', 'success', false);
                
                // Hide panel
                this.hideSettingsPanel();
            }
            
            showAuditLogs() {
                const logs = this.getAuditLogs(50);
                const logsHTML = logs.map(log => `
                    <div class="audit-log-item">
                        <div class="log-time">${new Date(log.timestamp).toLocaleString()}</div>
                        <div class="log-type">${log.type}</div>
                        <div class="log-data">${JSON.stringify(log.data, null, 2)}</div>
                    </div>
                `).join('');
                
                const auditModal = `
                    <div class="audit-modal">
                        <div class="audit-modal-content">
                            <div class="audit-header">
                                <h3>📝 Logs de Auditoría</h3>
                                <button class="audit-close" onclick="document.querySelector('.audit-modal').remove()">&times;</button>
                            </div>
                            <div class="audit-body">
                                ${logsHTML || '<p>No hay logs disponibles</p>'}
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', auditModal);
            }
        }
        
        // Initialize Advanced Wallet Panel
        let walletPanel;
        
        document.addEventListener('DOMContentLoaded', function() {
            walletPanel = new AdvancedWalletPanel();
            console.log('💰 Advanced Wallet Panel ready');
        });
        
        // Expose globally for debugging
        window.walletPanel = walletPanel;
    </script>
    
</body>
</html>